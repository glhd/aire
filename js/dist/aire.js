(function () {
  'use strict';

  /**
   * @name toDate
   * @category Common Helpers
   * @summary Convert the given argument to an instance of Date.
   *
   * @description
   * Convert the given argument to an instance of Date.
   *
   * If the argument is an instance of Date, the function returns its clone.
   *
   * If the argument is a number, it is treated as a timestamp.
   *
   * If the argument is none of the above, the function returns Invalid Date.
   *
   * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
   *
   * @param {Date|Number} argument - the value to convert
   * @returns {Date} the parsed date in the local time zone
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Clone the date:
   * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert the timestamp to date:
   * const result = toDate(1392098430000)
   * //=> Tue Feb 11 2014 11:30:30
   */
  function toDate(argument) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var argStr = Object.prototype.toString.call(argument); // Clone the date

    if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
      // Prevent the date to lose the milliseconds when passed to new Date() in IE10
      return new Date(argument.getTime());
    } else if (typeof argument === 'number' || argStr === '[object Number]') {
      return new Date(argument);
    } else {
      if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
        // eslint-disable-next-line no-console
        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

        console.warn(new Error().stack);
      }

      return new Date(NaN);
    }
  }

  /**
   * @name isValid
   * @category Common Helpers
   * @summary Is the given date valid?
   *
   * @description
   * Returns false if argument is Invalid Date and true otherwise.
   * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * Invalid Date is a Date, whose time value is NaN.
   *
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - Now `isValid` doesn't throw an exception
   *   if the first argument is not an instance of Date.
   *   Instead, argument is converted beforehand using `toDate`.
   *
   *   Examples:
   *
   *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
   *   |---------------------------|---------------|---------------|
   *   | `new Date()`              | `true`        | `true`        |
   *   | `new Date('2016-01-01')`  | `true`        | `true`        |
   *   | `new Date('')`            | `false`       | `false`       |
   *   | `new Date(1488370835081)` | `true`        | `true`        |
   *   | `new Date(NaN)`           | `false`       | `false`       |
   *   | `'2016-01-01'`            | `TypeError`   | `true`        |
   *   | `''`                      | `TypeError`   | `false`       |
   *   | `1488370835081`           | `TypeError`   | `true`        |
   *   | `NaN`                     | `TypeError`   | `false`       |
   *
   *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
   *   that try to coerce arguments to the expected type
   *   (which is also the case with other *date-fns* functions).
   *
   * @param {*} date - the date to check
   * @returns {Boolean} the date is valid
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // For the valid date:
   * var result = isValid(new Date(2014, 1, 31))
   * //=> true
   *
   * @example
   * // For the value, convertable into a date:
   * var result = isValid(1393804800000)
   * //=> true
   *
   * @example
   * // For the invalid date:
   * var result = isValid(new Date(''))
   * //=> false
   */

  function isValid(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var date = toDate(dirtyDate);
    return !isNaN(date);
  }

  function toInteger(dirtyNumber) {
    if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
      return NaN;
    }

    var number = Number(dirtyNumber);

    if (isNaN(number)) {
      return number;
    }

    return number < 0 ? Math.ceil(number) : Math.floor(number);
  }

  var MILLISECONDS_IN_MINUTE = 60000;
  /**
   * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
   * They usually appear for dates that denote time before the timezones were introduced
   * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
   * and GMT+01:00:00 after that date)
   *
   * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
   * which would lead to incorrect calculations.
   *
   * This function returns the timezone offset in milliseconds that takes seconds in account.
   */

  function getTimezoneOffsetInMilliseconds(dirtyDate) {
    var date = new Date(dirtyDate.getTime());
    var baseTimezoneOffset = date.getTimezoneOffset();
    date.setSeconds(0, 0);
    var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE;
    return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
  }

  var MILLISECONDS_IN_HOUR = 3600000;
  var MILLISECONDS_IN_MINUTE$1 = 60000;
  var DEFAULT_ADDITIONAL_DIGITS = 2;
  var patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
  };
  var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
  var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
  var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
  /**
   * @name parseISO
   * @category Common Helpers
   * @summary Parse ISO string
   *
   * @description
   * Parse the given string in ISO 8601 format and return an instance of Date.
   *
   * Function accepts complete ISO 8601 formats as well as partial implementations.
   * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
   *
   * If the argument isn't a string, the function cannot parse the string or
   * the values are invalid, it returns Invalid Date.
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - The previous `parse` implementation was renamed to `parseISO`.
   *
   *   ```javascript
   *   // Before v2.0.0
   *   parse('2016-01-01')
   *
   *   // v2.0.0 onward
   *   parseISO('2016-01-01')
   *   ```
   *
   * - `parseISO` now validates separate date and time values in ISO-8601 strings
   *   and returns `Invalid Date` if the date is invalid.
   *
   *   ```javascript
   *   parseISO('2018-13-32')
   *   //=> Invalid Date
   *   ```
   *
   * - `parseISO` now doesn't fall back to `new Date` constructor
   *   if it fails to parse a string argument. Instead, it returns `Invalid Date`.
   *
   * @param {String} argument - the value to convert
   * @param {Object} [options] - an object with options.
   * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
   * @returns {Date} the parsed date in the local time zone
   * @throws {TypeError} 1 argument required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Convert string '2014-02-11T11:30:30' to date:
   * var result = parseISO('2014-02-11T11:30:30')
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert string '+02014101' to date,
   * // if the additional number of digits in the extended year format is 1:
   * var result = parseISO('+02014101', { additionalDigits: 1 })
   * //=> Fri Apr 11 2014 00:00:00
   */

  function parseISO(argument, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    }

    var options = dirtyOptions || {};
    var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger(options.additionalDigits);

    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
      throw new RangeError('additionalDigits must be 0, 1 or 2');
    }

    if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
      return new Date(NaN);
    }

    var dateStrings = splitDateString(argument);
    var date;

    if (dateStrings.date) {
      var parseYearResult = parseYear(dateStrings.date, additionalDigits);
      date = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }

    if (isNaN(date) || !date) {
      return new Date(NaN);
    }

    var timestamp = date.getTime();
    var time = 0;
    var offset;

    if (dateStrings.time) {
      time = parseTime(dateStrings.time);

      if (isNaN(time) || time === null) {
        return new Date(NaN);
      }
    }

    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone);

      if (isNaN(offset)) {
        return new Date(NaN);
      }
    } else {
      var fullTime = timestamp + time;
      var fullTimeDate = new Date(fullTime);
      offset = getTimezoneOffsetInMilliseconds(fullTimeDate); // Adjust time when it's coming from DST

      var fullTimeDateNextDay = new Date(fullTime);
      fullTimeDateNextDay.setDate(fullTimeDate.getDate() + 1);
      var offsetDiff = getTimezoneOffsetInMilliseconds(fullTimeDateNextDay) - offset;

      if (offsetDiff > 0) {
        offset += offsetDiff;
      }
    }

    return new Date(timestamp + time + offset);
  }

  function splitDateString(dateString) {
    var dateStrings = {};
    var array = dateString.split(patterns.dateTimeDelimiter);
    var timeString;

    if (/:/.test(array[0])) {
      dateStrings.date = null;
      timeString = array[0];
    } else {
      dateStrings.date = array[0];
      timeString = array[1];

      if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
        dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
        timeString = dateString.substr(dateStrings.date.length, dateString.length);
      }
    }

    if (timeString) {
      var token = patterns.timezone.exec(timeString);

      if (token) {
        dateStrings.time = timeString.replace(token[1], '');
        dateStrings.timezone = token[1];
      } else {
        dateStrings.time = timeString;
      }
    }

    return dateStrings;
  }

  function parseYear(dateString, additionalDigits) {
    var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
    var captures = dateString.match(regex); // Invalid ISO-formatted year

    if (!captures) return {
      year: null
    };
    var year = captures[1] && parseInt(captures[1]);
    var century = captures[2] && parseInt(captures[2]);
    return {
      year: century == null ? year : century * 100,
      restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
  }

  function parseDate(dateString, year) {
    // Invalid ISO-formatted year
    if (year === null) return null;
    var captures = dateString.match(dateRegex); // Invalid ISO-formatted string

    if (!captures) return null;
    var isWeekDate = !!captures[4];
    var dayOfYear = parseDateUnit(captures[1]);
    var month = parseDateUnit(captures[2]) - 1;
    var day = parseDateUnit(captures[3]);
    var week = parseDateUnit(captures[4]);
    var dayOfWeek = parseDateUnit(captures[5]) - 1;

    if (isWeekDate) {
      if (!validateWeekDate(year, week, dayOfWeek)) {
        return new Date(NaN);
      }

      return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
      var date = new Date(0);

      if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
        return new Date(NaN);
      }

      date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
      return date;
    }
  }

  function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
  }

  function parseTime(timeString) {
    var captures = timeString.match(timeRegex);
    if (!captures) return null; // Invalid ISO-formatted time

    var hours = parseTimeUnit(captures[1]);
    var minutes = parseTimeUnit(captures[2]);
    var seconds = parseTimeUnit(captures[3]);

    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }

    return hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE$1 + seconds * 1000;
  }

  function parseTimeUnit(value) {
    return value && parseFloat(value.replace(',', '.')) || 0;
  }

  function parseTimezone(timezoneString) {
    if (timezoneString === 'Z') return 0;
    var captures = timezoneString.match(timezoneRegex);
    if (!captures) return 0;
    var sign = captures[1] === '+' ? -1 : 1;
    var hours = parseInt(captures[2]);
    var minutes = captures[3] && parseInt(captures[3]) || 0;

    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }

    return sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE$1);
  }

  function dayOfISOWeekYear(isoWeekYear, week, day) {
    var date = new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    var fourthOfJanuaryDay = date.getUTCDay() || 7;
    var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  } // Validation functions
  // February is null to handle the leap year (using ||)


  var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100;
  }

  function validateDate(year, month, date) {
    return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
  }

  function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
  }

  function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
  }

  function validateTime(hours, minutes, seconds) {
    if (hours === 24) {
      return minutes === 0 && seconds === 0;
    }

    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
  }

  function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
  }

  function leapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
  }

  function isValidDate(inDate) {
    if (inDate instanceof Date) {
      return !isNaN(inDate);
    }

    // reformat if supplied as mm.dd.yyyy (period delimiter)
    if (typeof inDate === 'string') {
      var pos = inDate.indexOf('.');
      if (pos > 0 && pos <= 6) {
        inDate = inDate.replace(/\./g, '-');
      }

      // if date is mm-dd-yyyy or yyyy-mm-dd
      if (inDate.length === 10) {
        return isValid(parseISO(inDate));
      }
    }

    var testDate = new Date(inDate);
    var yr = testDate.getFullYear();
    var mo = testDate.getMonth();
    var day = testDate.getDate();

    var daysInMonth = [31, leapYear(yr) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

    if (yr < 1000) {
      return false;
    }
    if (isNaN(mo)) {
      return false;
    }
    if (mo + 1 > 12) {
      return false;
    }
    if (isNaN(day)) {
      return false;
    }
    if (day > daysInMonth[mo]) {
      return false;
    }

    return true;
  }

  var rules = {
    required: function(val) {
      var str;

      if (val === undefined || val === null) {
        return false;
      }

      str = String(val).replace(/\s/g, '');
      return str.length > 0 ? true : false;
    },

    required_if: function(val, req, attribute) {
      req = this.getParameters();
      if (this.validator._objectPath(this.validator.input, req[0]) === req[1]) {
        return this.validator.getRule('required').validate(val);
      }

      return true;
    },

    required_unless: function(val, req, attribute) {
      req = this.getParameters();
      if (this.validator._objectPath(this.validator.input, req[0]) !== req[1]) {
        return this.validator.getRule('required').validate(val);
      }

      return true;
    },

    required_with: function(val, req, attribute) {
      if (this.validator._objectPath(this.validator.input, req)) {
        return this.validator.getRule('required').validate(val);
      }

      return true;
    },

    required_with_all: function(val, req, attribute) {
      req = this.getParameters();

      for (var i = 0; i < req.length; i++) {
        if (!this.validator._objectPath(this.validator.input, req[i])) {
          return true;
        }
      }

      return this.validator.getRule('required').validate(val);
    },

    required_without: function(val, req, attribute) {
      if (this.validator._objectPath(this.validator.input, req)) {
        return true;
      }

      return this.validator.getRule('required').validate(val);
    },

    required_without_all: function(val, req, attribute) {
      req = this.getParameters();

      for (var i = 0; i < req.length; i++) {
        if (this.validator._objectPath(this.validator.input, req[i])) {
          return true;
        }
      }

      return this.validator.getRule('required').validate(val);
    },

    boolean: function(val) {
      return (
        val === true ||
        val === false ||
        val === 0 ||
        val === 1 ||
        val === '0' ||
        val === '1' ||
        val === 'true' ||
        val === 'false'
      );
    },

    // compares the size of strings
    // with numbers, compares the value
    size: function(val, req, attribute) {
      if (val) {
        req = parseFloat(req);

        var size = this.getSize();

        return size === req;
      }

      return true;
    },

    string: function(val, req, attribute) {
      return typeof val === 'string';
    },

    sometimes: function(val) {
      return true;
    },

    /**
     * Compares the size of strings or the value of numbers if there is a truthy value
     */
    min: function(val, req, attribute) {
      var size = this.getSize();
      return size >= req;
    },

    /**
     * Compares the size of strings or the value of numbers if there is a truthy value
     */
    max: function(val, req, attribute) {
      var size = this.getSize();
      return size <= req;
    },

    between: function(val, req, attribute) {
      req = this.getParameters();
      var size = this.getSize();
      var min = parseFloat(req[0], 10);
      var max = parseFloat(req[1], 10);
      return size >= min && size <= max;
    },

    email: function(val) {
      var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
      return re.test(val);
    },

    numeric: function(val) {
      var num;

      num = Number(val); // tries to convert value to a number. useful if value is coming from form element

      if (typeof num === 'number' && !isNaN(num) && typeof val !== 'boolean') {
        return true;
      } else {
        return false;
      }
    },

    array: function(val) {
      return val instanceof Array;
    },

    url: function(url) {
      return /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_\+.~#?&/=]*)/i.test(url);
    },

    alpha: function(val) {
      return /^[a-zA-Z]+$/.test(val);
    },

    alpha_dash: function(val) {
      return /^[a-zA-Z0-9_\-]+$/.test(val);
    },

    alpha_num: function(val) {
      return /^[a-zA-Z0-9]+$/.test(val);
    },

    same: function(val, req) {
      var val1 = this.validator._flattenObject(this.validator.input)[req];
      var val2 = val;

      if (val1 === val2) {
        return true;
      }

      return false;
    },

    different: function(val, req) {
      var val1 = this.validator._flattenObject(this.validator.input)[req];
      var val2 = val;

      if (val1 !== val2) {
        return true;
      }

      return false;
    },

    in: function(val, req) {
      var list, i;

      if (val) {
        list = this.getParameters();
      }

      if (val && !(val instanceof Array)) {
        var localValue = val;

        for (i = 0; i < list.length; i++) {
          if (typeof list[i] === 'string') {
            localValue = String(val);
          }

          if (localValue === list[i]) {
            return true;
          }
        }

        return false;
      }

      if (val && val instanceof Array) {
        for (i = 0; i < val.length; i++) {
          if (list.indexOf(val[i]) < 0) {
            return false;
          }
        }
      }

      return true;
    },

    not_in: function(val, req) {
      var list = this.getParameters();
      var len = list.length;
      var returnVal = true;

      for (var i = 0; i < len; i++) {
        var localValue = val;

        if (typeof list[i] === 'string') {
          localValue = String(val);
        }

        if (localValue === list[i]) {
          returnVal = false;
          break;
        }
      }

      return returnVal;
    },

    accepted: function(val) {
      if (val === 'on' || val === 'yes' || val === 1 || val === '1' || val === true) {
        return true;
      }

      return false;
    },

    confirmed: function(val, req, key) {
      var confirmedKey = key + '_confirmation';

      if (this.validator.input[confirmedKey] === val) {
        return true;
      }

      return false;
    },

    integer: function(val) {
      return String(parseInt(val, 10)) === String(val);
    },

    digits: function(val, req) {
      var numericRule = this.validator.getRule('numeric');
      if (numericRule.validate(val) && String(val).length === parseInt(req)) {
        return true;
      }

      return false;
    },

    digits_between: function(val) {
      var numericRule = this.validator.getRule('numeric');
      var req = this.getParameters();
      var valueDigitsCount = String(val).length;
      var min = parseFloat(req[0], 10);
      var max = parseFloat(req[1], 10);

      if (numericRule.validate(val) && valueDigitsCount >= min && valueDigitsCount <= max) {
        return true;
      }

      return false;
    },

    regex: function(val, req) {
      var mod = /[g|i|m]{1,3}$/;
      var flag = req.match(mod);
      flag = flag ? flag[0] : '';
      req = req.replace(mod, '').slice(1, -1);
      req = new RegExp(req, flag);
      return !!req.test(val);
    },

    date: function(val, format) {
      return isValidDate(val);
    },

    present: function(val) {
      return typeof val !== 'undefined';
    },

    after: function(val, req) {
      var val1 = this.validator.input[req];
      var val2 = val;

      if (!isValidDate(val1)) {
        return false;
      }
      if (!isValidDate(val2)) {
        return false;
      }

      if (new Date(val1).getTime() < new Date(val2).getTime()) {
        return true;
      }

      return false;
    },

    after_or_equal: function(val, req) {
      var val1 = this.validator.input[req];
      var val2 = val;

      if (!isValidDate(val1)) {
        return false;
      }
      if (!isValidDate(val2)) {
        return false;
      }

      if (new Date(val1).getTime() <= new Date(val2).getTime()) {
        return true;
      }

      return false;
    },

    before: function(val, req) {
      var val1 = this.validator.input[req];
      var val2 = val;

      if (!isValidDate(val1)) {
        return false;
      }
      if (!isValidDate(val2)) {
        return false;
      }

      if (new Date(val1).getTime() > new Date(val2).getTime()) {
        return true;
      }

      return false;
    },

    before_or_equal: function(val, req) {
      var val1 = this.validator.input[req];
      var val2 = val;

      if (!isValidDate(val1)) {
        return false;
      }
      if (!isValidDate(val2)) {
        return false;
      }

      if (new Date(val1).getTime() >= new Date(val2).getTime()) {
        return true;
      }

      return false;
    },

    hex: function(val) {
      return /^[0-9a-f]+$/i.test(val);
    }
  };

  var missedRuleValidator = function() {
    throw new Error('Validator `' + this.name + '` is not defined!');
  };
  var missedRuleMessage;

  function Rule(name, fn, async) {
    this.name = name;
    this.fn = fn;
    this.passes = null;
    this._customMessage = undefined;
    this.async = async;
  }

  Rule.prototype = {
    /**
     * Validate rule
     *
     * @param  {mixed} inputValue
     * @param  {mixed} ruleValue
     * @param  {string} attribute
     * @param  {function} callback
     * @return {boolean|undefined}
     */
    validate: function(inputValue, ruleValue, attribute, callback) {
      var _this = this;
      this._setValidatingData(attribute, inputValue, ruleValue);
      if (typeof callback === 'function') {
        this.callback = callback;
        var handleResponse = function(passes, message) {
          _this.response(passes, message);
        };

        if (this.async) {
          return this._apply(inputValue, ruleValue, attribute, handleResponse);
        } else {
          return handleResponse(this._apply(inputValue, ruleValue, attribute));
        }
      }
      return this._apply(inputValue, ruleValue, attribute);
    },

    /**
     * Apply validation function
     *
     * @param  {mixed} inputValue
     * @param  {mixed} ruleValue
     * @param  {string} attribute
     * @param  {function} callback
     * @return {boolean|undefined}
     */
    _apply: function(inputValue, ruleValue, attribute, callback) {
      var fn = this.isMissed() ? missedRuleValidator : this.fn;

      return fn.apply(this, [inputValue, ruleValue, attribute, callback]);
    },

    /**
     * Set validating data
     *
     * @param {string} attribute
     * @param {mixed} inputValue
     * @param {mixed} ruleValue
     * @return {void}
     */
    _setValidatingData: function(attribute, inputValue, ruleValue) {
      this.attribute = attribute;
      this.inputValue = inputValue;
      this.ruleValue = ruleValue;
    },

    /**
     * Get parameters
     *
     * @return {array}
     */
    getParameters: function() {
      var value = [];

      if (typeof this.ruleValue === 'string') {
        value = this.ruleValue.split(',');
      }

      if (typeof this.ruleValue === 'number') {
        value.push(this.ruleValue);
      }

      if (this.ruleValue instanceof Array) {
        value = this.ruleValue;
      }

      return value;
    },

    /**
     * Get true size of value
     *
     * @return {integer|float}
     */
    getSize: function() {
      var value = this.inputValue;

      if (value instanceof Array) {
        return value.length;
      }

      if (typeof value === 'number') {
        return value;
      }

      if (this.validator._hasNumericRule(this.attribute)) {
        return parseFloat(value, 10);
      }

      return value.length;
    },

    /**
     * Get the type of value being checked; numeric or string.
     *
     * @return {string}
     */
    _getValueType: function() {
      if (typeof this.inputValue === 'number' || this.validator._hasNumericRule(this.attribute)) {
        return 'numeric';
      }

      return 'string';
    },

    /**
     * Set the async callback response
     *
     * @param  {boolean|undefined} passes  Whether validation passed
     * @param  {string|undefined} message Custom error message
     * @return {void}
     */
    response: function(passes, message) {
      this.passes = passes === undefined || passes === true;
      this._customMessage = message;
      this.callback(this.passes, message);
    },

    /**
     * Set validator instance
     *
     * @param {Validator} validator
     * @return {void}
     */
    setValidator: function(validator) {
      this.validator = validator;
    },

    /**
     * Check if rule is missed
     *
     * @return {boolean}
     */
    isMissed: function() {
      return typeof this.fn !== 'function';
    },

    get customMessage() {
      return this.isMissed() ? missedRuleMessage : this._customMessage;
    }
  };

  var manager = {
    /**
     * List of async rule names
     *
     * @type {Array}
     */
    asyncRules: [],

    /**
     * Implicit rules (rules to always validate)
     *
     * @type {Array}
     */
    implicitRules: [
      'required',
      'required_if',
      'required_unless',
      'required_with',
      'required_with_all',
      'required_without',
      'required_without_all',
      'accepted',
      'present'
    ],

    /**
     * Get rule by name
     *
     * @param  {string} name
     * @param {Validator}
     * @return {Rule}
     */
    make: function(name, validator) {
      var async = this.isAsync(name);
      var rule = new Rule(name, rules[name], async);
      rule.setValidator(validator);
      return rule;
    },

    /**
     * Determine if given rule is async
     *
     * @param  {string}  name
     * @return {boolean}
     */
    isAsync: function(name) {
      for (var i = 0, len = this.asyncRules.length; i < len; i++) {
        if (this.asyncRules[i] === name) {
          return true;
        }
      }
      return false;
    },

    /**
     * Determine if rule is implicit (should always validate)
     *
     * @param {string} name
     * @return {boolean}
     */
    isImplicit: function(name) {
      return this.implicitRules.indexOf(name) > -1;
    },

    /**
     * Register new rule
     *
     * @param  {string}   name
     * @param  {function} fn
     * @return {void}
     */
    register: function(name, fn) {
      rules[name] = fn;
    },

    /**
     * Register new implicit rule
     *
     * @param  {string}   name
     * @param  {function} fn
     * @return {void}
     */
    registerImplicit: function(name, fn) {
      this.register(name, fn);
      this.implicitRules.push(name);
    },

    /**
     * Register async rule
     *
     * @param  {string}   name
     * @param  {function} fn
     * @return {void}
     */
    registerAsync: function(name, fn) {
      this.register(name, fn);
      this.asyncRules.push(name);
    },

    /**
     * Register implicit async rule
     *
     * @param  {string}   name
     * @param  {function} fn
     * @return {void}
     */
    registerAsyncImplicit: function(name, fn) {
      this.registerImplicit(name, fn);
      this.asyncRules.push(name);
    },

    registerMissedRuleValidator: function(fn, message) {
      missedRuleValidator = fn;
      missedRuleMessage = message;
    }
  };

  var rules_1 = manager;

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
  }

  var replacements = {

    /**
     * Between replacement (replaces :min and :max)
     *
     * @param  {string} template
     * @param  {Rule} rule
     * @return {string}
     */
    between: function(template, rule) {
      var parameters = rule.getParameters();
      return this._replacePlaceholders(rule, template, {
        min: parameters[0],
        max: parameters[1]
      });
    },

    /**
     * Digits-Between replacement (replaces :min and :max)
     *
     * @param  {string} template
     * @param  {Rule} rule
     * @return {string}
     */
    digits_between: function(template, rule) {
      var parameters = rule.getParameters();
      return this._replacePlaceholders(rule, template, {
        min: parameters[0],
        max: parameters[1]
      });
    },

    /**
     * Required_if replacement.
     *
     * @param  {string} template
     * @param  {Rule} rule
     * @return {string}
     */
    required_if: function(template, rule) {
      var parameters = rule.getParameters();
      return this._replacePlaceholders(rule, template, {
        other: this._getAttributeName(parameters[0]),
        value: parameters[1]
      });
    },

    /**
     * Required_unless replacement.
     *
     * @param  {string} template
     * @param  {Rule} rule
     * @return {string}
     */
    required_unless: function(template, rule) {
      var parameters = rule.getParameters();
      return this._replacePlaceholders(rule, template, {
        other: this._getAttributeName(parameters[0]),
        value: parameters[1]
      });
    },

    /**
     * Required_with replacement.
     *
     * @param  {string} template
     * @param  {Rule} rule
     * @return {string}
     */
    required_with: function(template, rule) {
      var parameters = rule.getParameters();
      return this._replacePlaceholders(rule, template, {
        field: this._getAttributeName(parameters[0])
      });
    },

    /**
     * Required_with_all replacement.
     *
     * @param  {string} template
     * @param  {Rule} rule
     * @return {string}
     */
    required_with_all: function(template, rule) {
      var parameters = rule.getParameters();
      var getAttributeName = this._getAttributeName.bind(this);
      return this._replacePlaceholders(rule, template, {
        fields: parameters.map(getAttributeName).join(', ')
      });
    },

    /**
     * Required_without replacement.
     *
     * @param  {string} template
     * @param  {Rule} rule
     * @return {string}
     */
    required_without: function(template, rule) {
      var parameters = rule.getParameters();
      return this._replacePlaceholders(rule, template, {
        field: this._getAttributeName(parameters[0])
      });
    },

    /**
     * Required_without_all replacement.
     *
     * @param  {string} template
     * @param  {Rule} rule
     * @return {string}
     */
    required_without_all: function(template, rule) {
      var parameters = rule.getParameters();
      var getAttributeName = this._getAttributeName.bind(this);
      return this._replacePlaceholders(rule, template, {
        fields: parameters.map(getAttributeName).join(', ')
      });
    },

    /**
     * After replacement.
     *
     * @param  {string} template
     * @param  {Rule} rule
     * @return {string}
     */
    after: function(template, rule) {
      var parameters = rule.getParameters();
      return this._replacePlaceholders(rule, template, {
        after: this._getAttributeName(parameters[0])
      });
    },

    /**
     * Before replacement.
     *
     * @param  {string} template
     * @param  {Rule} rule
     * @return {string}
     */
    before: function(template, rule) {
      var parameters = rule.getParameters();
      return this._replacePlaceholders(rule, template, {
        before: this._getAttributeName(parameters[0])
      });
    },

    /**
     * After_or_equal replacement.
     *
     * @param  {string} template
     * @param  {Rule} rule
     * @return {string}
     */
    after_or_equal: function(template, rule) {
      var parameters = rule.getParameters();
      return this._replacePlaceholders(rule, template, {
        after_or_equal: this._getAttributeName(parameters[0])
      });
    },

    /**
     * Before_or_equal replacement.
     *
     * @param  {string} template
     * @param  {Rule} rule
     * @return {string}
     */
    before_or_equal: function(template, rule) {
      var parameters = rule.getParameters();
      return this._replacePlaceholders(rule, template, {
        before_or_equal: this._getAttributeName(parameters[0])
      });
    },

    /**
     * Same replacement.
     *
     * @param  {string} template
     * @param  {Rule} rule
     * @return {string}
     */
    same: function(template, rule) {
      var parameters = rule.getParameters();
      return this._replacePlaceholders(rule, template, {
        same: this._getAttributeName(parameters[0])
      });
    },
  };

  function formatter(attribute) {
    return attribute.replace(/[_\[]/g, ' ').replace(/]/g, '');
  }

  var attributes = {
    replacements: replacements,
    formatter: formatter
  };

  var Messages = function(lang, messages) {
    this.lang = lang;
    this.messages = messages;
    this.customMessages = {};
    this.attributeNames = {};
  };

  Messages.prototype = {
    constructor: Messages,

    /**
     * Set custom messages
     *
     * @param {object} customMessages
     * @return {void}
     */
    _setCustom: function(customMessages) {
      this.customMessages = customMessages || {};
    },

    /**
     * Set custom attribute names.
     *
     * @param {object} attributes
     */
    _setAttributeNames: function(attributes) {
      this.attributeNames = attributes;
    },

    /**
     * Set the attribute formatter.
     *
     * @param {fuction} func
     * @return {void}
     */
    _setAttributeFormatter: function(func) {
      this.attributeFormatter = func;
    },

    /**
     * Get attribute name to display.
     *
     * @param  {string} attribute
     * @return {string}
     */
    _getAttributeName: function(attribute) {
      var name = attribute;
      if (this.attributeNames.hasOwnProperty(attribute)) {
        return this.attributeNames[attribute];
      } else if (this.messages.attributes.hasOwnProperty(attribute)) {
        name = this.messages.attributes[attribute];
      }

      if (this.attributeFormatter) {
        name = this.attributeFormatter(name);
      }

      return name;
    },

    /**
     * Get all messages
     *
     * @return {object}
     */
    all: function() {
      return this.messages;
    },

    /**
     * Render message
     *
     * @param  {Rule} rule
     * @return {string}
     */
    render: function(rule) {
      if (rule.customMessage) {
        return rule.customMessage;
      }
      var template = this._getTemplate(rule);

      var message;
      if (attributes.replacements[rule.name]) {
        message = attributes.replacements[rule.name].apply(this, [template, rule]);
      } else {
        message = this._replacePlaceholders(rule, template, {});
      }

      return message;
    },

    /**
     * Get the template to use for given rule
     *
     * @param  {Rule} rule
     * @return {string}
     */
    _getTemplate: function(rule) {

      var messages = this.messages;
      var template = messages.def;
      var customMessages = this.customMessages;
      var formats = [rule.name + '.' + rule.attribute, rule.name];

      for (var i = 0, format; i < formats.length; i++) {
        format = formats[i];
        if (customMessages.hasOwnProperty(format)) {
          template = customMessages[format];
          break;
        } else if (messages.hasOwnProperty(format)) {
          template = messages[format];
          break;
        }
      }

      if (typeof template === 'object') {
        template = template[rule._getValueType()];
      }

      return template;
    },

    /**
     * Replace placeholders in the template using the data object
     *
     * @param  {Rule} rule
     * @param  {string} template
     * @param  {object} data
     * @return {string}
     */
    _replacePlaceholders: function(rule, template, data) {
      var message, attribute;

      data.attribute = this._getAttributeName(rule.attribute);
      data[rule.name] = data[rule.name] || rule.getParameters().join(',');

      if (typeof template === 'string' && typeof data === 'object') {
        message = template;

        for (attribute in data) {
          message = message.replace(new RegExp(':' + attribute, 'g'), data[attribute]);
        }
      }

      return message;
    }

  };

  var messages = Messages;

  var en = {
    accepted: 'The :attribute must be accepted.',
    after: 'The :attribute must be after :after.',
    after_or_equal: 'The :attribute must be equal or after :after_or_equal.',
    alpha: 'The :attribute field must contain only alphabetic characters.',
    alpha_dash: 'The :attribute field may only contain alpha-numeric characters, as well as dashes and underscores.',
    alpha_num: 'The :attribute field must be alphanumeric.',
    before: 'The :attribute must be before :before.',
    before_or_equal: 'The :attribute must be equal or before :before_or_equal.',
    between: 'The :attribute field must be between :min and :max.',
    confirmed: 'The :attribute confirmation does not match.',
    email: 'The :attribute format is invalid.',
    date: 'The :attribute is not a valid date format.',
    def: 'The :attribute attribute has errors.',
    digits: 'The :attribute must be :digits digits.',
    digits_between: 'The :attribute field must be between :min and :max digits.',
    different: 'The :attribute and :different must be different.',
    in: 'The selected :attribute is invalid.',
    integer: 'The :attribute must be an integer.',
    hex: 'The :attribute field should have hexadecimal format',
    min: {
      numeric: 'The :attribute must be at least :min.',
      string: 'The :attribute must be at least :min characters.'
    },
    max: {
      numeric: 'The :attribute may not be greater than :max.',
      string: 'The :attribute may not be greater than :max characters.'
    },
    not_in: 'The selected :attribute is invalid.',
    numeric: 'The :attribute must be a number.',
    present: 'The :attribute field must be present (but can be empty).',
    required: 'The :attribute field is required.',
    required_if: 'The :attribute field is required when :other is :value.',
    required_unless: 'The :attribute field is required when :other is not :value.',
    required_with: 'The :attribute field is required when :field is not empty.',
    required_with_all: 'The :attribute field is required when :fields are not empty.',
    required_without: 'The :attribute field is required when :field is empty.',
    required_without_all: 'The :attribute field is required when :fields are empty.',
    same: 'The :attribute and :same fields must match.',
    size: {
      numeric: 'The :attribute must be :size.',
      string: 'The :attribute must be :size characters.'
    },
    string: 'The :attribute must be a string.',
    url: 'The :attribute format is invalid.',
    regex: 'The :attribute format is invalid.',
    attributes: {}
  };

  var require_method = commonjsRequire;

  var container = {

    messages: {},

    /**
     * Set messages for language
     *
     * @param {string} lang
     * @param {object} rawMessages
     * @return {void}
     */
    _set: function(lang, rawMessages) {
      this.messages[lang] = rawMessages;
    },

    /**
     * Set message for given language's rule.
     *
     * @param {string} lang
     * @param {string} attribute
     * @param {string|object} message
     * @return {void}
     */
    _setRuleMessage: function(lang, attribute, message) {
      this._load(lang);
      if (message === undefined) {
        message = this.messages[lang].def;
      }

      this.messages[lang][attribute] = message;
    },

    /**
     * Load messages (if not already loaded)
     *
     * @param  {string} lang
     * @return {void}
     */
    _load: function(lang) {
      if (!this.messages[lang]) {
        try {
          var rawMessages = require_method('./lang/' + lang);
          this._set(lang, rawMessages);
        } catch (e) {}
      }
    },

    /**
     * Get raw messages for language
     *
     * @param  {string} lang
     * @return {object}
     */
    _get: function(lang) {
      this._load(lang);
      return this.messages[lang];
    },

    /**
     * Make messages for given language
     *
     * @param  {string} lang
     * @return {Messages}
     */
    _make: function(lang) {
      this._load(lang);
      return new messages(lang, this.messages[lang]);
    }

  };

  var lang = container;

  var Errors = function() {
    this.errors = {};
  };

  Errors.prototype = {
    constructor: Errors,

    /**
     * Add new error message for given attribute
     *
     * @param  {string} attribute
     * @param  {string} message
     * @return {void}
     */
    add: function(attribute, message) {
      if (!this.has(attribute)) {
        this.errors[attribute] = [];
      }

      if (this.errors[attribute].indexOf(message) === -1) {
        this.errors[attribute].push(message);
      }
    },

    /**
     * Returns an array of error messages for an attribute, or an empty array
     *
     * @param  {string} attribute A key in the data object being validated
     * @return {array} An array of error messages
     */
    get: function(attribute) {
      if (this.has(attribute)) {
        return this.errors[attribute];
      }

      return [];
    },

    /**
     * Returns the first error message for an attribute, false otherwise
     *
     * @param  {string} attribute A key in the data object being validated
     * @return {string|false} First error message or false
     */
    first: function(attribute) {
      if (this.has(attribute)) {
        return this.errors[attribute][0];
      }

      return false;
    },

    /**
     * Get all error messages from all failing attributes
     *
     * @return {Object} Failed attribute names for keys and an array of messages for values
     */
    all: function() {
      return this.errors;
    },

    /**
     * Determine if there are any error messages for an attribute
     *
     * @param  {string}  attribute A key in the data object being validated
     * @return {boolean}
     */
    has: function(attribute) {
      if (this.errors.hasOwnProperty(attribute)) {
        return true;
      }

      return false;
    }
  };

  var errors = Errors;

  function AsyncResolvers(onFailedOne, onResolvedAll) {
    this.onResolvedAll = onResolvedAll;
    this.onFailedOne = onFailedOne;
    this.resolvers = {};
    this.resolversCount = 0;
    this.passed = [];
    this.failed = [];
    this.firing = false;
  }

  AsyncResolvers.prototype = {

    /**
     * Add resolver
     *
     * @param {Rule} rule
     * @return {integer}
     */
    add: function(rule) {
      var index = this.resolversCount;
      this.resolvers[index] = rule;
      this.resolversCount++;
      return index;
    },

    /**
     * Resolve given index
     *
     * @param  {integer} index
     * @return {void}
     */
    resolve: function(index) {
      var rule = this.resolvers[index];
      if (rule.passes === true) {
        this.passed.push(rule);
      } else if (rule.passes === false) {
        this.failed.push(rule);
        this.onFailedOne(rule);
      }

      this.fire();
    },

    /**
     * Determine if all have been resolved
     *
     * @return {boolean}
     */
    isAllResolved: function() {
      return (this.passed.length + this.failed.length) === this.resolversCount;
    },

    /**
     * Attempt to fire final all resolved callback if completed
     *
     * @return {void}
     */
    fire: function() {

      if (!this.firing) {
        return;
      }

      if (this.isAllResolved()) {
        this.onResolvedAll(this.failed.length === 0);
      }

    },

    /**
     * Enable firing
     *
     * @return {void}
     */
    enableFiring: function() {
      this.firing = true;
    }

  };

  var async = AsyncResolvers;

  var Validator$1 = function (input, rules, customMessages) {
    var lang$1 = Validator$1.getDefaultLang();
    this.input = input || {};

    this.messages = lang._make(lang$1);
    this.messages._setCustom(customMessages);
    this.setAttributeFormatter(Validator$1.prototype.attributeFormatter);

    this.errors = new errors();
    this.errorCount = 0;

    this.hasAsync = false;
    this.rules = this._parseRules(rules);
  };

  Validator$1.prototype = {

    constructor: Validator$1,

    /**
     * Default language
     *
     * @type {string}
     */
    lang: 'en',

    /**
     * Numeric based rules
     *
     * @type {array}
     */
    numericRules: ['integer', 'numeric'],

    /**
     * Attribute formatter.
     *
     * @type {function}
     */
    attributeFormatter: attributes.formatter,

    /**
     * Run validator
     *
     * @return {boolean} Whether it passes; true = passes, false = fails
     */
    check: function () {

      for (var attribute in this.rules) {
        var attributeRules = this.rules[attribute];
        var inputValue = this._objectPath(this.input, attribute);

        if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {
          continue;
        }

        for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {
          ruleOptions = attributeRules[i];
          rule = this.getRule(ruleOptions.name);

          if (!this._isValidatable(rule, inputValue)) {
            continue;
          }

          rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);
          if (!rulePassed) {
            this._addFailure(rule);
          }

          if (this._shouldStopValidating(attribute, rulePassed)) {
            break;
          }
        }
      }

      return this.errorCount === 0;
    },

    /**
     * Run async validator
     *
     * @param {function} passes
     * @param {function} fails
     * @return {void}
     */
    checkAsync: function (passes, fails) {
      var _this = this;
      passes = passes || function () {};
      fails = fails || function () {};

      var failsOne = function (rule, message) {
        _this._addFailure(rule, message);
      };

      var resolvedAll = function (allPassed) {
        if (allPassed) {
          passes();
        } else {
          fails();
        }
      };

      var asyncResolvers = new async(failsOne, resolvedAll);

      var validateRule = function (inputValue, ruleOptions, attribute, rule) {
        return function () {
          var resolverIndex = asyncResolvers.add(rule);
          rule.validate(inputValue, ruleOptions.value, attribute, function () {
            asyncResolvers.resolve(resolverIndex);
          });
        };
      };

      for (var attribute in this.rules) {
        var attributeRules = this.rules[attribute];
        var inputValue = this._objectPath(this.input, attribute);

        if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {
          continue;
        }

        for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {
          ruleOptions = attributeRules[i];

          rule = this.getRule(ruleOptions.name);

          if (!this._isValidatable(rule, inputValue)) {
            continue;
          }

          validateRule(inputValue, ruleOptions, attribute, rule)();
        }
      }

      asyncResolvers.enableFiring();
      asyncResolvers.fire();
    },

    /**
     * Add failure and error message for given rule
     *
     * @param {Rule} rule
     */
    _addFailure: function (rule) {
      var msg = this.messages.render(rule);
      this.errors.add(rule.attribute, msg);
      this.errorCount++;
    },

    /**
     * Flatten nested object, normalizing { foo: { bar: 1 } } into: { 'foo.bar': 1 }
     *
     * @param  {object} nested object
     * @return {object} flattened object
     */
    _flattenObject: function (obj) {
      var flattened = {};

      function recurse(current, property) {
        if (!property && Object.getOwnPropertyNames(current).length === 0) {
          return;
        }
        if (Object(current) !== current || Array.isArray(current)) {
          flattened[property] = current;
        } else {
          var isEmpty = true;
          for (var p in current) {
            isEmpty = false;
            recurse(current[p], property ? property + '.' + p : p);
          }
          if (isEmpty) {
            flattened[property] = {};
          }
        }
      }
      if (obj) {
        recurse(obj);
      }
      return flattened;
    },

    /**
     * Extract value from nested object using string path with dot notation
     *
     * @param  {object} object to search in
     * @param  {string} path inside object
     * @return {any|void} value under the path
     */
    _objectPath: function (obj, path) {
      if (Object.prototype.hasOwnProperty.call(obj, path)) {
        return obj[path];
      }

      var keys = path.replace(/\[(\w+)\]/g, '.$1').replace(/^\./, '').split('.');
      var copy = {};
      for (var attr in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, attr)) {
          copy[attr] = obj[attr];
        }
      }

      for (var i = 0, l = keys.length; i < l; i++) {
        if (typeof copy === 'object' && copy !== null && Object.hasOwnProperty.call(copy, keys[i])) {
          copy = copy[keys[i]];
        } else {
          return;
        }
      }
      return copy;
    },

    /**
     * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }
     *
     * @param  {object} rules
     * @return {object}
     */
    _parseRules: function (rules) {

      var parsedRules = {};
      rules = this._flattenObject(rules);

      for (var attribute in rules) {

        var rulesArray = rules[attribute];

        this._parseRulesCheck(attribute, rulesArray, parsedRules);
      }
      return parsedRules;


    },

    _parseRulesCheck: function (attribute, rulesArray, parsedRules, wildCardValues) {
      if (attribute.indexOf('*') > -1) {
        this._parsedRulesRecurse(attribute, rulesArray, parsedRules, wildCardValues);
      } else {
        this._parseRulesDefault(attribute, rulesArray, parsedRules, wildCardValues);
      }
    },

    _parsedRulesRecurse: function (attribute, rulesArray, parsedRules, wildCardValues) {
      var parentPath = attribute.substr(0, attribute.indexOf('*') - 1);
      var propertyValue = this._objectPath(this.input, parentPath);

      if (propertyValue) {
        for (var propertyNumber = 0; propertyNumber < propertyValue.length; propertyNumber++) {
          var workingValues = wildCardValues ? wildCardValues.slice() : [];
          workingValues.push(propertyNumber);
          this._parseRulesCheck(attribute.replace('*', propertyNumber), rulesArray, parsedRules, workingValues);
        }
      }
    },

    _parseRulesDefault: function (attribute, rulesArray, parsedRules, wildCardValues) {
      var attributeRules = [];

      if (rulesArray instanceof Array) {
        rulesArray = this._prepareRulesArray(rulesArray);
      }

      if (typeof rulesArray === 'string') {
        rulesArray = rulesArray.split('|');
      }

      for (var i = 0, len = rulesArray.length, rule; i < len; i++) {
        rule = typeof rulesArray[i] === 'string' ? this._extractRuleAndRuleValue(rulesArray[i]) : rulesArray[i];
        if (rule.value) {
          rule.value = this._replaceWildCards(rule.value, wildCardValues);
          this._replaceWildCardsMessages(wildCardValues);
        }

        if (rules_1.isAsync(rule.name)) {
          this.hasAsync = true;
        }
        attributeRules.push(rule);
      }

      parsedRules[attribute] = attributeRules;
    },

    _replaceWildCards: function (path, nums) {

      if (!nums) {
        return path;
      }

      var path2 = path;
      nums.forEach(function (value) {
        if(Array.isArray(path2)){
          path2 = path2[0];
        }
        pos = path2.indexOf('*');
        if (pos === -1) {
          return path2;
        }
        path2 = path2.substr(0, pos) + value + path2.substr(pos + 1);
      });
      if(Array.isArray(path)){
        path[0] = path2;
        path2 = path;
      }
      return path2;
    },

    _replaceWildCardsMessages: function (nums) {
      var customMessages = this.messages.customMessages;
      var self = this;
      Object.keys(customMessages).forEach(function (key) {
        if (nums) {
          var newKey = self._replaceWildCards(key, nums);
          customMessages[newKey] = customMessages[key];
        }
      });

      this.messages._setCustom(customMessages);
    },
    /**
     * Prepare rules if it comes in Array. Check for objects. Need for type validation.
     *
     * @param  {array} rulesArray
     * @return {array}
     */
    _prepareRulesArray: function (rulesArray) {
      var rules = [];

      for (var i = 0, len = rulesArray.length; i < len; i++) {
        if (typeof rulesArray[i] === 'object') {
          for (var rule in rulesArray[i]) {
            rules.push({
              name: rule,
              value: rulesArray[i][rule]
            });
          }
        } else {
          rules.push(rulesArray[i]);
        }
      }

      return rules;
    },

    /**
     * Determines if the attribute is supplied with the original data object.
     *
     * @param  {array} attribute
     * @return {boolean}
     */
    _suppliedWithData: function (attribute) {
      return this.input.hasOwnProperty(attribute);
    },

    /**
     * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3
     *
     * @param  {string} ruleString min:3
     * @return {object} object containing the name of the rule and value
     */
    _extractRuleAndRuleValue: function (ruleString) {
      var rule = {},
        ruleArray;

      rule.name = ruleString;

      if (ruleString.indexOf(':') >= 0) {
        ruleArray = ruleString.split(':');
        rule.name = ruleArray[0];
        rule.value = ruleArray.slice(1).join(':');
      }

      return rule;
    },

    /**
     * Determine if attribute has any of the given rules
     *
     * @param  {string}  attribute
     * @param  {array}   findRules
     * @return {boolean}
     */
    _hasRule: function (attribute, findRules) {
      var rules = this.rules[attribute] || [];
      for (var i = 0, len = rules.length; i < len; i++) {
        if (findRules.indexOf(rules[i].name) > -1) {
          return true;
        }
      }
      return false;
    },

    /**
     * Determine if attribute has any numeric-based rules.
     *
     * @param  {string}  attribute
     * @return {Boolean}
     */
    _hasNumericRule: function (attribute) {
      return this._hasRule(attribute, this.numericRules);
    },

    /**
     * Determine if rule is validatable
     *
     * @param  {Rule}   rule
     * @param  {mixed}  value
     * @return {boolean}
     */
    _isValidatable: function (rule, value) {
      if (rules_1.isImplicit(rule.name)) {
        return true;
      }

      return this.getRule('required').validate(value);
    },

    /**
     * Determine if we should stop validating.
     *
     * @param  {string} attribute
     * @param  {boolean} rulePassed
     * @return {boolean}
     */
    _shouldStopValidating: function (attribute, rulePassed) {

      var stopOnAttributes = this.stopOnAttributes;
      if (typeof stopOnAttributes === 'undefined' || stopOnAttributes === false || rulePassed === true) {
        return false;
      }

      if (stopOnAttributes instanceof Array) {
        return stopOnAttributes.indexOf(attribute) > -1;
      }

      return true;
    },

    /**
     * Set custom attribute names.
     *
     * @param {object} attributes
     * @return {void}
     */
    setAttributeNames: function (attributes) {
      this.messages._setAttributeNames(attributes);
    },

    /**
     * Set the attribute formatter.
     *
     * @param {fuction} func
     * @return {void}
     */
    setAttributeFormatter: function (func) {
      this.messages._setAttributeFormatter(func);
    },

    /**
     * Get validation rule
     *
     * @param  {string} name
     * @return {Rule}
     */
    getRule: function (name) {
      return rules_1.make(name, this);
    },

    /**
     * Stop on first error.
     *
     * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.
     * @return {void}
     */
    stopOnError: function (attributes) {
      this.stopOnAttributes = attributes;
    },

    /**
     * Determine if validation passes
     *
     * @param {function} passes
     * @return {boolean|undefined}
     */
    passes: function (passes) {
      var async = this._checkAsync('passes', passes);
      if (async) {
        return this.checkAsync(passes);
      }
      return this.check();
    },

    /**
     * Determine if validation fails
     *
     * @param {function} fails
     * @return {boolean|undefined}
     */
    fails: function (fails) {
      var async = this._checkAsync('fails', fails);
      if (async) {
        return this.checkAsync(function () {}, fails);
      }
      return !this.check();
    },

    /**
     * Check if validation should be called asynchronously
     *
     * @param  {string}   funcName Name of the caller
     * @param  {function} callback
     * @return {boolean}
     */
    _checkAsync: function (funcName, callback) {
      var hasCallback = typeof callback === 'function';
      if (this.hasAsync && !hasCallback) {
        throw funcName + ' expects a callback when async rules are being tested.';
      }

      return this.hasAsync || hasCallback;
    }

  };

  /**
   * Set messages for language
   *
   * @param {string} lang
   * @param {object} messages
   * @return {this}
   */
  Validator$1.setMessages = function (lang$1, messages) {
    lang._set(lang$1, messages);
    return this;
  };

  /**
   * Get messages for given language
   *
   * @param  {string} lang
   * @return {Messages}
   */
  Validator$1.getMessages = function (lang$1) {
    return lang._get(lang$1);
  };

  /**
   * Set default language to use
   *
   * @param {string} lang
   * @return {void}
   */
  Validator$1.useLang = function (lang) {
    this.prototype.lang = lang;
  };

  /**
   * Get default language
   *
   * @return {string}
   */
  Validator$1.getDefaultLang = function () {
    return this.prototype.lang;
  };

  /**
   * Set the attribute formatter.
   *
   * @param {fuction} func
   * @return {void}
   */
  Validator$1.setAttributeFormatter = function (func) {
    this.prototype.attributeFormatter = func;
  };

  /**
   * Stop on first error.
   *
   * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.
   * @return {void}
   */
  Validator$1.stopOnError = function (attributes) {
    this.prototype.stopOnAttributes = attributes;
  };

  /**
   * Register custom validation rule
   *
   * @param  {string}   name
   * @param  {function} fn
   * @param  {string}   message
   * @return {void}
   */
  Validator$1.register = function (name, fn, message) {
    var lang$1 = Validator$1.getDefaultLang();
    rules_1.register(name, fn);
    lang._setRuleMessage(lang$1, name, message);
  };

  /**
   * Register custom validation rule
   *
   * @param  {string}   name
   * @param  {function} fn
   * @param  {string}   message
   * @return {void}
   */
  Validator$1.registerImplicit = function (name, fn, message) {
    var lang$1 = Validator$1.getDefaultLang();
    rules_1.registerImplicit(name, fn);
    lang._setRuleMessage(lang$1, name, message);
  };

  /**
   * Register asynchronous validation rule
   *
   * @param  {string}   name
   * @param  {function} fn
   * @param  {string}   message
   * @return {void}
   */
  Validator$1.registerAsync = function (name, fn, message) {
    var lang$1 = Validator$1.getDefaultLang();
    rules_1.registerAsync(name, fn);
    lang._setRuleMessage(lang$1, name, message);
  };

  /**
   * Register asynchronous validation rule
   *
   * @param  {string}   name
   * @param  {function} fn
   * @param  {string}   message
   * @return {void}
   */
  Validator$1.registerAsyncImplicit = function (name, fn, message) {
    var lang$1 = Validator$1.getDefaultLang();
    rules_1.registerAsyncImplicit(name, fn);
    lang._setRuleMessage(lang$1, name, message);
  };

  /**
   * Register validator for missed validation rule
   *
   * @param  {string}   name
   * @param  {function} fn
   * @param  {string}   message
   * @return {void}
   */
  Validator$1.registerMissedRuleValidator = function(fn, message) {
    rules_1.registerMissedRuleValidator(fn, message);
  };

  var validator = Validator$1;

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }

    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var resolveElement = function resolveElement(target) {
    if ('string' === typeof target) {
      return document.querySelector(target);
    }

    return target;
  };

  var getData = function getData(form) {
    var formData = new FormData(form);
    var values = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = formData.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _slicedToArray(_step.value, 2),
            key = _step$value[0],
            value = _step$value[1];

        var name = key.replace(/\[]$/, '');
        var multiple = name !== key;

        if (values[name]) {
          if (!(values[name] instanceof Array)) {
            values[name] = [values[name]];
          }

          values[name].push(value);
        } else {
          values[name] = multiple ? [value] : value;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return values;
  };

  var booted = false;

  var boot = function boot() {
    if (!booted) {
      Validator.registerMissedRuleValidator(function () {
        return true;
      }, '');
    }

    booted = true;
  };

  var config = {
    'templates': {
      'error': {
        'prefix': '<li>',
        'suffix': '</li>'
      }
    },
    'classnames': {
      'none': {},
      'valid': {},
      'invalid': {}
    },
    'locale': 'en'
  };
  var configure = function configure(customConfig) {
    config = customConfig; // Use configured language

    var locale = config.locale;

    var localeMessages = require("./lang/" + locale);

    Validator.setMessages(locale, localeMessages);
    Validator.useLang(locale);
  }; // FIXME: This still needs major perf work

  var defaultRenderer = function defaultRenderer(_ref) {
    var form = _ref.form,
        errors = _ref.errors,
        data = _ref.data,
        rules = _ref.rules,
        refs = _ref.refs,
        touched = _ref.touched;
    var _config = config,
        templates = _config.templates,
        classnames = _config.classnames;
    Object.keys(rules).forEach(function (name) {
      // Stop if we don't have refs to this field
      if (!(name in refs)) {
        return;
      }

      var fails = touched.has(name) && name in errors;
      var passes = touched.has(name) && !fails && name in data;

      if ('errors' in refs[name]) {
        if (passes) {
          refs[name].errors[0].innerHTML = '';
        } else if (fails) {
          refs[name].errors[0].innerHTML = errors[name].map(function (message) {
            return "".concat(templates.error.prefix).concat(message).concat(templates.error.suffix);
          }).join('');
        }
      }

      Object.entries(refs[name]).forEach(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
            name = _ref3[0],
            elements = _ref3[1];

        elements.forEach(function (element) {
          if (name in classnames.valid) {
            var passes_classnames = classnames.valid[name].split(' ');

            if (passes_classnames.length) {
              if (passes) {
                var _element$classList;

                (_element$classList = element.classList).add.apply(_element$classList, _toConsumableArray(passes_classnames));
              } else if (fails) {
                var _element$classList2;

                (_element$classList2 = element.classList).remove.apply(_element$classList2, _toConsumableArray(passes_classnames));
              }
            }
          }

          if (name in classnames.invalid) {
            var fails_classnames = classnames.invalid[name].split(' ');

            if (fails_classnames.length) {
              if (fails) {
                var _element$classList3;

                (_element$classList3 = element.classList).add.apply(_element$classList3, _toConsumableArray(fails_classnames));
              } else if (passes) {
                var _element$classList4;

                (_element$classList4 = element.classList).remove.apply(_element$classList4, _toConsumableArray(fails_classnames));
              }
            }
          }

          if (name in classnames.none) {
            var none_classnames = classnames.none[name].split(' ');

            if (none_classnames.length) {
              if (!passes && !fails) {
                var _element$classList5;

                (_element$classList5 = element.classList).add.apply(_element$classList5, _toConsumableArray(none_classnames));
              } else {
                var _element$classList6;

                (_element$classList6 = element.classList).remove.apply(_element$classList6, _toConsumableArray(none_classnames));
              }
            }
          }
        });
      });
    });
  };

  var renderer = defaultRenderer;
  var setRenderer = function setRenderer(customRenderer) {
    renderer = customRenderer;
  };
  var supported = 'undefined' !== typeof FormData && 'getAll' in FormData.prototype;
  var connect = function connect(target) {
    var rules = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var messages = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (!supported) {
      return null;
    }

    boot();
    var form = resolveElement(target);
    var refs = {};

    var storeRef = function storeRef(parent, component, element) {
      refs[parent] = refs[parent] || {};
      refs[parent][component] = refs[parent][component] || [];
      refs[parent][component].push(element);
    };

    form.querySelectorAll('[data-aire-component]').forEach(function (element) {
      if ('aireFor' in element.dataset) {
        var parent = element.dataset.aireFor;
        var component = element.dataset.aireComponent; // Add the component to the refs

        storeRef(parent, component, element); // If we have a validation key, let the element also be referenced by it

        if ('aireValidationKey' in element.dataset && component !== element.dataset.aireValidationKey) {
          storeRef(parent, element.dataset.aireValidationKey, element);
        }
      }
    });
    var validator;
    var connected = true;
    var touched = new Set();

    var touch = function touch(e) {
      var name = e.target.getAttribute('name');

      if (name) {
        touched.add(name.replace(/\[]$/, ''));
      }
    };

    var debounce;

    var run = function run(e) {
      if ('undefined' !== typeof e && 'target' in e) {
        touch(e);
      }

      var latestRun = 0;
      clearTimeout(debounce);
      debounce = setTimeout(function () {
        var data = getData(form);
        validator = new Validator(data, rules, messages); // Because some validators may run async, we'll store a reference
        // to the run "id" so that we can cancel the callbacks if another
        // validation started before the callbacks were fired

        var activeRun = ++latestRun; // If this is the first run, "touch" anything that has a value

        if (1 === activeRun) {
          Object.entries(data).forEach(function (_ref4) {
            var _ref5 = _slicedToArray(_ref4, 2),
                key = _ref5[0],
                value = _ref5[1];

            if (null === value || 'undefined' === typeof value || '' === value) {
              return;
            }

            if (Array.isArray(value) && 0 === value.length) {
              return;
            } // Don't mark as touched if it has errors in it


            if (key in refs && 'errors' in refs[key] && refs[key].errors[0].childElementCount > 0) {
              return;
            }

            touched.add(key);
          });
        }

        var validated = function validated() {
          if (connected && activeRun === latestRun) {
            renderer({
              form: form,
              rules: rules,
              touched: touched,
              refs: refs,
              data: data,
              errors: validator.errors.all()
            });
          }
        };

        validator.checkAsync(validated, validated);
      }, 250);
    };

    form.addEventListener('change', run, true);
    form.addEventListener('keyup', run, true);
    form.addEventListener('focus', touch, true);
    run();

    var disconnect = function disconnect() {
      connected = false;
      clearTimeout(debounce);
      form.removeEventListener('change', run);
      form.removeEventListener('keyup', run);
      form.removeEventListener('focus', touch);
    };

    return {
      get valid() {
        return 'undefined' !== typeof validator && 0 === Object.keys(validator.errors.all()).length;
      },

      get data() {
        return 'undefined' === typeof validator ? getData(form) : validator.input;
      },

      get validator() {
        return validator;
      },

      run: run,
      disconnect: disconnect
    };
  };

  var Aire = /*#__PURE__*/Object.freeze({
    __proto__: null,
    configure: configure,
    setRenderer: setRenderer,
    supported: supported,
    connect: connect
  });

  validator.setMessages('en', en);
  window.Validator = validator;
  window.Aire = Aire;

}());
