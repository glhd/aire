<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Test Form</title>
</head>
<body>

<form action="" method="POST" class="" data-aire-component="form" data-aire-for="" data-aire-id="0">
	
	<input type="hidden" name="_token" value="QKqqjIZgqFKCHYHqog3Tx4TCdjuFTxyffhPkF78E" />
	
	<div class="mb-6" data-aire-component="group" data-aire-for="accepted">
		
		<div class="">
			
			<label class="flex items-center" data-aire-component="label" data-aire-for="accepted" for="__aire-0-accepted">
				<input type="checkbox" value="1" class="pr-2" data-aire-component="checkbox" name="accepted" data-aire-for="accepted" id="__aire-0-accepted" />
				<span class="ml-2 flex-1" data-aire-component="wrapper" data-aire-for="accepted">
		Accept the terms
	</span>
			</label>
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="accepted">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="reference_date">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-reference_date">
			Enter a reference date:
		</label>
		
		<div class="">
			
			<input
				type="date"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="reference_date"
				data-aire-for="reference_date"
				id="__aire-0-reference_date" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="reference_date">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="after_reference">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-after_reference">
			Must be after whatever date is entered above:
		</label>
		
		<div class="">
			
			<input
				type="date"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="after_reference"
				data-aire-for="after_reference"
				id="__aire-0-after_reference" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="after_reference">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="after_or_equal_reference">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-after_or_equal_reference">
			Must be after or equal to the reference date above:
		</label>
		
		<div class="">
			
			<input
				type="date"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="after_or_equal_reference"
				data-aire-for="after_or_equal_reference"
				id="__aire-0-after_or_equal_reference" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="after_or_equal_reference">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="before_reference">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-before_reference">
			Must be before whatever date is entered above:
		</label>
		
		<div class="">
			
			<input
				type="date"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="before_reference"
				data-aire-for="before_reference"
				id="__aire-0-before_reference" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="before_reference">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="before_or_equal_reference">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-before_or_equal_reference">
			Must be before or equal to the reference date above:
		</label>
		
		<div class="">
			
			<input
				type="date"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="before_or_equal_reference"
				data-aire-for="before_or_equal_reference"
				id="__aire-0-before_or_equal_reference" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="before_or_equal_reference">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="date">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-date">
			Must be a valid date format:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="date"
				data-aire-for="date"
				id="__aire-0-date" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="date">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="alpha">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-alpha">
			Must be only letters:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="alpha"
				data-aire-for="alpha"
				id="__aire-0-alpha" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="alpha">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="alpha_dash">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-alpha_dash">
			Must be letters, numbers, dashes, and underscores:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="alpha_dash"
				data-aire-for="alpha_dash"
				id="__aire-0-alpha_dash" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="alpha_dash">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="alpha_num">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-alpha_num">
			Must be letters or numbers:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="alpha_num"
				data-aire-for="alpha_num"
				id="__aire-0-alpha_num" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="alpha_num">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="array">
		<label class="inline-block mb-2" data-aire-component="label" data-aire-for="">
			Must be array:
		</label>
		
		<div class="">
			
			<div class="" data-aire-component="wrapper" data-aire-for="array">
				
				<label class="flex items-baseline mb-2 ml-2 border-transparent border-l" data-aire-component="label" data-aire-for="array">
					<input
						type="checkbox" class="" data-aire-component="checkbox-group" name="array[]" data-aire-for="array"
						value="coates"
					
					/>
					<span class="flex-1 ml-2" data-aire-component="label_wrapper" data-aire-for="array">
				Ta-Nehisi Coates
			</span>
				</label>
				
				<label class="flex items-baseline mb-2 ml-2 border-transparent border-l" data-aire-component="label" data-aire-for="array">
					<input
						type="checkbox" class="" data-aire-component="checkbox-group" name="array[]" data-aire-for="array"
						value="roth"
					
					/>
					<span class="flex-1 ml-2" data-aire-component="label_wrapper" data-aire-for="array">
				Philip Roth
			</span>
				</label>
				
				<label class="flex items-baseline mb-2 ml-2 border-transparent border-l" data-aire-component="label" data-aire-for="array">
					<input
						type="checkbox" class="" data-aire-component="checkbox-group" name="array[]" data-aire-for="array"
						value="patchett"
					
					/>
					<span class="flex-1 ml-2" data-aire-component="label_wrapper" data-aire-for="array">
				Ann Patchett
			</span>
				</label>
			
			</div>
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="array">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="between">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-between">
			Must be between 2.0 and 4.0 (floats only for now):
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="between"
				data-aire-for="between"
				id="__aire-0-between" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="between">
		</ul>
	
	</div>
	
	<div class="flex">
		<div class="w-1/2 pr-1">
			<div class="mb-6" data-aire-component="group" data-aire-for="confirmed">
				<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-confirmed">
					Must be confirmed:
				</label>
				
				<div class="">
					
					<input
						type="text"
						class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
						data-aire-component="input"
						name="confirmed"
						data-aire-for="confirmed"
						id="__aire-0-confirmed" />
				
				</div>
				
				<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="confirmed">
				</ul>
			
			</div>
		
		</div>
		<div class="w-1/2 pl-1">
			<div class="mb-6" data-aire-component="group" data-aire-for="confirmed_confirmation">
				<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-confirmed_confirmation">
					Confirm:
				</label>
				
				<div class="">
					
					<input
						type="text"
						class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
						data-aire-component="input"
						name="confirmed_confirmation"
						data-aire-for="confirmed_confirmation"
						id="__aire-0-confirmed_confirmation" />
				
				</div>
				
				<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="confirmed_confirmation">
				</ul>
			
			</div>
		
		</div>
	</div>
	
	<div class="flex">
		<div class="w-1/2 pr-1">
			<div class="mb-6" data-aire-component="group" data-aire-for="different_from">
				<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-different_from">
					Enter any value:
				</label>
				
				<div class="">
					
					<input
						type="text"
						class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
						data-aire-component="input"
						name="different_from"
						data-aire-for="different_from"
						id="__aire-0-different_from" />
				
				</div>
				
				<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="different_from">
				</ul>
			
			</div>
		
		</div>
		<div class="w-1/2 pl-1">
			<div class="mb-6" data-aire-component="group" data-aire-for="different">
				<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-different">
					Must be different from that value:
				</label>
				
				<div class="">
					
					<input
						type="text"
						class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
						data-aire-component="input"
						name="different"
						data-aire-for="different"
						id="__aire-0-different" />
				
				</div>
				
				<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="different">
				</ul>
			
			</div>
		
		</div>
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="digits">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-digits">
			Must be 5 digits:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="digits"
				data-aire-for="digits"
				id="__aire-0-digits" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="digits">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="email">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-email">
			Must be a valid email:
		</label>
		
		<div class="">
			
			<input
				type="email"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="email"
				data-aire-for="email"
				id="__aire-0-email" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="email">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="in">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-in">
			Must be foo, bar, or baz:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="in"
				data-aire-for="in"
				id="__aire-0-in" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="in">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="not_in">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-not_in">
			Must NOT be foo, bar, or baz:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="not_in"
				data-aire-for="not_in"
				id="__aire-0-not_in" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="not_in">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="integer">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-integer">
			Must be an integer:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="integer"
				data-aire-for="integer"
				id="__aire-0-integer" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="integer">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="min_string">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-min_string">
			Must be a string of at least 5 characters:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="min_string"
				data-aire-for="min_string"
				id="__aire-0-min_string" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="min_string">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="min_number">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-min_number">
			Must be a number that is 5 or above:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="min_number"
				data-aire-for="min_number"
				id="__aire-0-min_number" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="min_number">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="max_string">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-max_string">
			Must be a string up to 5 characters:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="max_string"
				data-aire-for="max_string"
				id="__aire-0-max_string" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="max_string">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="max_number">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-max_number">
			Must be a number up to 5:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="max_number"
				data-aire-for="max_number"
				id="__aire-0-max_number" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="max_number">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="regex">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-regex">
			Must match the regular expression /^[a-z]\d{4}$/i
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="regex"
				data-aire-for="regex"
				id="__aire-0-regex" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="regex">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="numeric">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-numeric">
			Must be numeric:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="numeric"
				data-aire-for="numeric"
				id="__aire-0-numeric" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="numeric">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="required">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-required">
			Required input:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="required"
				data-aire-for="required"
				id="__aire-0-required" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="required">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="required_if">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-required_if">
			Only required if the above is &quot;yes&quot;:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="required_if"
				data-aire-for="required_if"
				id="__aire-0-required_if" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="required_if">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="required_unless">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-required_unless">
			Required unless the above is &quot;no&quot;:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="required_unless"
				data-aire-for="required_unless"
				id="__aire-0-required_unless" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="required_unless">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="required_with">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-required_with">
			Required if above is not empty:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="required_with"
				data-aire-for="required_with"
				id="__aire-0-required_with" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="required_with">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="required_with_all">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-required_with_all">
			Required if all of the above are not empty:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="required_with_all"
				data-aire-for="required_with_all"
				id="__aire-0-required_with_all" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="required_with_all">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="required_without">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-required_without">
			Required if above is empty:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="required_without"
				data-aire-for="required_without"
				id="__aire-0-required_without" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="required_without">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="required_without_all">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-required_without_all">
			Required if all of the above are empty:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="required_without_all"
				data-aire-for="required_without_all"
				id="__aire-0-required_without_all" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="required_without_all">
		</ul>
	
	</div>
	
	<div class="flex">
		<div class="w-1/2 pr-1">
			<div class="mb-6" data-aire-component="group" data-aire-for="same_target">
				<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-same_target">
					Enter anything:
				</label>
				
				<div class="">
					
					<input
						type="text"
						class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
						data-aire-component="input"
						name="same_target"
						data-aire-for="same_target"
						id="__aire-0-same_target" />
				
				</div>
				
				<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="same_target">
				</ul>
			
			</div>
		
		</div>
		<div class="w-1/2 pl-1">
			<div class="mb-6" data-aire-component="group" data-aire-for="same">
				<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-same">
					Must be the same:
				</label>
				
				<div class="">
					
					<input
						type="text"
						class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
						data-aire-component="input"
						name="same"
						data-aire-for="same"
						id="__aire-0-same" />
				
				</div>
				
				<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="same">
				</ul>
			
			</div>
		
		</div>
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="size_number">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-size_number">
			Must be the number 5:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="size_number"
				data-aire-for="size_number"
				id="__aire-0-size_number" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="size_number">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="size_string">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-size_string">
			Must be 5 characters:
		</label>
		
		<div class="">
			
			<input
				type="text"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="size_string"
				data-aire-for="size_string"
				id="__aire-0-size_string" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="size_string">
		</ul>
	
	</div>
	
	<div class="mb-6" data-aire-component="group" data-aire-for="url">
		<label class="inline-block mb-2 cursor-pointer" data-aire-component="label" data-aire-for="" for="__aire-0-url">
			Must be a URL:
		</label>
		
		<div class="">
			
			<input
				type="url"
				class="block w-full p-2 text-base leading-normal bg-white border rounded-sm text-gray-900"
				data-aire-component="input"
				name="url"
				data-aire-for="url"
				id="__aire-0-url" />
		
		</div>
		
		<ul class="list-reset mt-2 mb-3 hidden" data-aire-component="errors" data-aire-for="url">
		</ul>
	
	</div>
	
	<script defer>
	(function() {
		'use strict';
		
		function leapYear(year) {
			return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
		}
		
		function isValidDate(inDate) {
			var valid = true;
			
			// reformat if supplied as mm.dd.yyyy (period delimiter)
			if (typeof inDate === 'string') {
				var pos = inDate.indexOf('.');
				if ((pos > 0 && pos <= 6)) {
					inDate = inDate.replace(/\./g, '-');
				}
			}
			
			var testDate = new Date(inDate);
			var yr = testDate.getFullYear();
			var mo = testDate.getMonth();
			var day = testDate.getDate();
			
			var daysInMonth = [31, (leapYear(yr) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
			
			if (yr < 1000) {
				return false;
			}
			if (isNaN(mo)) {
				return false;
			}
			if (mo + 1 > 12) {
				return false;
			}
			if (isNaN(day)) {
				return false;
			}
			if (day > daysInMonth[mo]) {
				return false;
			}
			
			return valid;
		}
		
		var rules = {
			
			required: function(val) {
				var str;
				
				if (val === undefined || val === null) {
					return false;
				}
				
				str = String(val).replace(/\s/g, "");
				return str.length > 0 ? true : false;
			},
			
			required_if: function(val, req, attribute) {
				req = this.getParameters();
				if (this.validator._objectPath(this.validator.input, req[0]) === req[1]) {
					return this.validator.getRule('required').validate(val);
				}
				
				return true;
			},
			
			required_unless: function(val, req, attribute) {
				req = this.getParameters();
				if (this.validator._objectPath(this.validator.input, req[0]) !== req[1]) {
					return this.validator.getRule('required').validate(val);
				}
				
				return true;
			},
			
			required_with: function(val, req, attribute) {
				if (this.validator._objectPath(this.validator.input, req)) {
					return this.validator.getRule('required').validate(val);
				}
				
				return true;
			},
			
			required_with_all: function(val, req, attribute) {
				
				req = this.getParameters();
				
				for (var i = 0; i < req.length; i++) {
					if (!this.validator._objectPath(this.validator.input, req[i])) {
						return true;
					}
				}
				
				return this.validator.getRule('required').validate(val);
			},
			
			required_without: function(val, req, attribute) {
				
				if (this.validator._objectPath(this.validator.input, req)) {
					return true;
				}
				
				return this.validator.getRule('required').validate(val);
			},
			
			required_without_all: function(val, req, attribute) {
				
				req = this.getParameters();
				
				for (var i = 0; i < req.length; i++) {
					if (this.validator._objectPath(this.validator.input, req[i])) {
						return true;
					}
				}
				
				return this.validator.getRule('required').validate(val);
			},
			
			'boolean': function(val) {
				return (
					val === true ||
					val === false ||
					val === 0 ||
					val === 1 ||
					val === '0' ||
					val === '1' ||
					val === 'true' ||
					val === 'false'
				);
			},
			
			// compares the size of strings
			// with numbers, compares the value
			size: function(val, req, attribute) {
				if (val) {
					req = parseFloat(req);
					
					var size = this.getSize();
					
					return size === req;
				}
				
				return true;
			},
			
			string: function(val, req, attribute) {
				return typeof val === 'string';
			},
			
			sometimes: function(val) {
				return true;
			},
			
			/**
			 * Compares the size of strings or the value of numbers if there is a truthy value
			 */
			min: function(val, req, attribute) {
				var size = this.getSize();
				return size >= req;
			},
			
			/**
			 * Compares the size of strings or the value of numbers if there is a truthy value
			 */
			max: function(val, req, attribute) {
				var size = this.getSize();
				return size <= req;
			},
			
			between: function(val, req, attribute) {
				req = this.getParameters();
				var size = this.getSize();
				var min = parseFloat(req[0], 10);
				var max = parseFloat(req[1], 10);
				return size >= min && size <= max;
			},
			
			email: function(val) {
				var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
				return re.test(val);
			},
			
			numeric: function(val) {
				var num;
				
				num = Number(val); // tries to convert value to a number. useful if value is coming from form element
				
				if (typeof num === 'number' && !isNaN(num) && typeof val !== 'boolean') {
					return true;
				} else {
					return false;
				}
			},
			
			array: function(val) {
				return val instanceof Array;
			},
			
			url: function(url) {
				return (/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/i).test(url);
			},
			
			alpha: function(val) {
				return (/^[a-zA-Z]+$/).test(val);
			},
			
			alpha_dash: function(val) {
				return (/^[a-zA-Z0-9_\-]+$/).test(val);
			},
			
			alpha_num: function(val) {
				return (/^[a-zA-Z0-9]+$/).test(val);
			},
			
			same: function(val, req) {
				var val1 = this.validator._flattenObject(this.validator.input)[req];
				var val2 = val;
				
				if (val1 === val2) {
					return true;
				}
				
				return false;
			},
			
			different: function(val, req) {
				var val1 = this.validator._flattenObject(this.validator.input)[req];
				var val2 = val;
				
				if (val1 !== val2) {
					return true;
				}
				
				return false;
			},
			
			"in": function(val, req) {
				var list, i;
				
				if (val) {
					list = this.getParameters();
				}
				
				if (val && !(val instanceof Array)) {
					var localValue = val;
					
					for (i = 0; i < list.length; i++) {
						if (typeof list[i] === 'string') {
							localValue = String(val);
						}
						
						if (localValue === list[i]) {
							return true;
						}
					}
					
					return false;
				}
				
				if (val && val instanceof Array) {
					for (i = 0; i < val.length; i++) {
						if (list.indexOf(val[i]) < 0) {
							return false;
						}
					}
				}
				
				return true;
			},
			
			not_in: function(val, req) {
				var list = this.getParameters();
				var len = list.length;
				var returnVal = true;
				
				for (var i = 0; i < len; i++) {
					var localValue = val;
					
					if (typeof list[i] === 'string') {
						localValue = String(val);
					}
					
					if (localValue === list[i]) {
						returnVal = false;
						break;
					}
				}
				
				return returnVal;
			},
			
			accepted: function(val) {
				if (val === 'on' || val === 'yes' || val === 1 || val === '1' || val === true) {
					return true;
				}
				
				return false;
			},
			
			confirmed: function(val, req, key) {
				var confirmedKey = key + '_confirmation';
				
				if (this.validator.input[confirmedKey] === val) {
					return true;
				}
				
				return false;
			},
			
			integer: function(val) {
				return String(parseInt(val, 10)) === String(val);
			},
			
			digits: function(val, req) {
				var numericRule = this.validator.getRule('numeric');
				if (numericRule.validate(val) && String(val).length === parseInt(req)) {
					return true;
				}
				
				return false;
			},
			
			regex: function(val, req) {
				var mod = /[g|i|m]{1,3}$/;
				var flag = req.match(mod);
				flag = flag ? flag[0] : "";
				req = req.replace(mod, "").slice(1, -1);
				req = new RegExp(req, flag);
				return !!req.test(val);
			},
			
			date: function(val, format) {
				return isValidDate(val);
			},
			
			present: function(val) {
				return typeof val !== 'undefined';
			},
			
			after: function(val, req) {
				var val1 = this.validator.input[req];
				var val2 = val;
				
				if (!isValidDate(val1)) {
					return false;
				}
				if (!isValidDate(val2)) {
					return false;
				}
				
				if (new Date(val1).getTime() < new Date(val2).getTime()) {
					return true;
				}
				
				return false;
			},
			
			after_or_equal: function(val, req) {
				var val1 = this.validator.input[req];
				var val2 = val;
				
				if (!isValidDate(val1)) {
					return false;
				}
				if (!isValidDate(val2)) {
					return false;
				}
				
				if (new Date(val1).getTime() <= new Date(val2).getTime()) {
					return true;
				}
				
				return false;
			},
			
			before: function(val, req) {
				var val1 = this.validator.input[req];
				var val2 = val;
				
				if (!isValidDate(val1)) {
					return false;
				}
				if (!isValidDate(val2)) {
					return false;
				}
				
				if (new Date(val1).getTime() > new Date(val2).getTime()) {
					return true;
				}
				
				return false;
			},
			
			before_or_equal: function(val, req) {
				var val1 = this.validator.input[req];
				var val2 = val;
				
				if (!isValidDate(val1)) {
					return false;
				}
				if (!isValidDate(val2)) {
					return false;
				}
				
				if (new Date(val1).getTime() >= new Date(val2).getTime()) {
					return true;
				}
				
				return false;
			},
			
			hex: function(val) {
				return (/^[0-9a-f]+$/i).test(val);
			}
		};
		
		var missedRuleValidator = function() {
			throw new Error('Validator `' + this.name + '` is not defined!');
		};
		var missedRuleMessage;
		
		function Rule(name, fn, async) {
			this.name = name;
			this.fn = fn;
			this.passes = null;
			this._customMessage = undefined;
			this.async = async;
		}
		
		Rule.prototype = {
			
			/**
			 * Validate rule
			 *
			 * @param  {mixed} inputValue
			 * @param  {mixed} ruleValue
			 * @param  {string} attribute
			 * @param  {function} callback
			 * @return {boolean|undefined}
			 */
			validate: function(inputValue, ruleValue, attribute, callback) {
				var _this = this;
				this._setValidatingData(attribute, inputValue, ruleValue);
				if (typeof callback === 'function') {
					this.callback = callback;
					var handleResponse = function(passes, message) {
						_this.response(passes, message);
					};
					
					if (this.async) {
						return this._apply(inputValue, ruleValue, attribute, handleResponse);
					} else {
						return handleResponse(this._apply(inputValue, ruleValue, attribute));
					}
				}
				return this._apply(inputValue, ruleValue, attribute);
			},
			
			/**
			 * Apply validation function
			 *
			 * @param  {mixed} inputValue
			 * @param  {mixed} ruleValue
			 * @param  {string} attribute
			 * @param  {function} callback
			 * @return {boolean|undefined}
			 */
			_apply: function(inputValue, ruleValue, attribute, callback) {
				var fn = this.isMissed() ? missedRuleValidator : this.fn;
				
				return fn.apply(this, [inputValue, ruleValue, attribute, callback]);
			},
			
			/**
			 * Set validating data
			 *
			 * @param {string} attribute
			 * @param {mixed} inputValue
			 * @param {mixed} ruleValue
			 * @return {void}
			 */
			_setValidatingData: function(attribute, inputValue, ruleValue) {
				this.attribute = attribute;
				this.inputValue = inputValue;
				this.ruleValue = ruleValue;
			},
			
			/**
			 * Get parameters
			 *
			 * @return {array}
			 */
			getParameters: function() {
				var value = [];
				
				if (typeof this.ruleValue === 'string') {
					value = this.ruleValue.split(',');
				}
				
				if (typeof this.ruleValue === 'number') {
					value.push(this.ruleValue);
				}
				
				if (this.ruleValue instanceof Array) {
					value = this.ruleValue;
				}
				
				return value;
			},
			
			/**
			 * Get true size of value
			 *
			 * @return {integer|float}
			 */
			getSize: function() {
				var value = this.inputValue;
				
				if (value instanceof Array) {
					return value.length;
				}
				
				if (typeof value === 'number') {
					return value;
				}
				
				if (this.validator._hasNumericRule(this.attribute)) {
					return parseFloat(value, 10);
				}
				
				return value.length;
			},
			
			/**
			 * Get the type of value being checked; numeric or string.
			 *
			 * @return {string}
			 */
			_getValueType: function() {
				
				if (typeof this.inputValue === 'number' || this.validator._hasNumericRule(this.attribute)) {
					return 'numeric';
				}
				
				return 'string';
			},
			
			/**
			 * Set the async callback response
			 *
			 * @param  {boolean|undefined} passes  Whether validation passed
			 * @param  {string|undefined} message Custom error message
			 * @return {void}
			 */
			response: function(passes, message) {
				this.passes = (passes === undefined || passes === true);
				this._customMessage = message;
				this.callback(this.passes, message);
			},
			
			/**
			 * Set validator instance
			 *
			 * @param {Validator} validator
			 * @return {void}
			 */
			setValidator: function(validator) {
				this.validator = validator;
			},
			
			/**
			 * Check if rule is missed
			 *
			 * @return {boolean}
			 */
			isMissed: function() {
				return typeof this.fn !== 'function';
			},
			
			get customMessage() {
				return this.isMissed() ? missedRuleMessage : this._customMessage;
			}
		};
		
		var manager = {
			
			/**
			 * List of async rule names
			 *
			 * @type {Array}
			 */
			asyncRules: [],
			
			/**
			 * Implicit rules (rules to always validate)
			 *
			 * @type {Array}
			 */
			implicitRules: [
				'required',
				'required_if',
				'required_unless',
				'required_with',
				'required_with_all',
				'required_without',
				'required_without_all',
				'accepted',
				'present'
			],
			
			/**
			 * Get rule by name
			 *
			 * @param  {string} name
			 * @param {Validator}
			 * @return {Rule}
			 */
			make: function(name, validator) {
				var async = this.isAsync(name);
				var rule = new Rule(name, rules[name], async);
				rule.setValidator(validator);
				return rule;
			},
			
			/**
			 * Determine if given rule is async
			 *
			 * @param  {string}  name
			 * @return {boolean}
			 */
			isAsync: function(name) {
				for (var i = 0, len = this.asyncRules.length; i < len; i++) {
					if (this.asyncRules[i] === name) {
						return true;
					}
				}
				return false;
			},
			
			/**
			 * Determine if rule is implicit (should always validate)
			 *
			 * @param {string} name
			 * @return {boolean}
			 */
			isImplicit: function(name) {
				return this.implicitRules.indexOf(name) > -1;
			},
			
			/**
			 * Register new rule
			 *
			 * @param  {string}   name
			 * @param  {function} fn
			 * @return {void}
			 */
			register: function(name, fn) {
				rules[name] = fn;
			},
			
			/**
			 * Register new implicit rule
			 *
			 * @param  {string}   name
			 * @param  {function} fn
			 * @return {void}
			 */
			registerImplicit: function(name, fn) {
				this.register(name, fn);
				this.implicitRules.push(name);
			},
			
			/**
			 * Register async rule
			 *
			 * @param  {string}   name
			 * @param  {function} fn
			 * @return {void}
			 */
			registerAsync: function(name, fn) {
				this.register(name, fn);
				this.asyncRules.push(name);
			},
			
			/**
			 * Register implicit async rule
			 *
			 * @param  {string}   name
			 * @param  {function} fn
			 * @return {void}
			 */
			registerAsyncImplicit: function(name, fn) {
				this.registerImplicit(name, fn);
				this.asyncRules.push(name);
			},
			
			registerMissedRuleValidator: function(fn, message) {
				missedRuleValidator = fn;
				missedRuleMessage = message;
			}
		};
		
		
		var rules_1 = manager;
		
		function commonjsRequire() {
			throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
		}
		
		var replacements = {
			
			/**
			 * Between replacement (replaces :min and :max)
			 *
			 * @param  {string} template
			 * @param  {Rule} rule
			 * @return {string}
			 */
			between: function(template, rule) {
				var parameters = rule.getParameters();
				return this._replacePlaceholders(rule, template, {
					min: parameters[0],
					max: parameters[1]
				});
			},
			
			/**
			 * Required_if replacement.
			 *
			 * @param  {string} template
			 * @param  {Rule} rule
			 * @return {string}
			 */
			required_if: function(template, rule) {
				var parameters = rule.getParameters();
				return this._replacePlaceholders(rule, template, {
					other: this._getAttributeName(parameters[0]),
					value: parameters[1]
				});
			},
			
			/**
			 * Required_unless replacement.
			 *
			 * @param  {string} template
			 * @param  {Rule} rule
			 * @return {string}
			 */
			required_unless: function(template, rule) {
				var parameters = rule.getParameters();
				return this._replacePlaceholders(rule, template, {
					other: this._getAttributeName(parameters[0]),
					value: parameters[1]
				});
			},
			
			/**
			 * Required_with replacement.
			 *
			 * @param  {string} template
			 * @param  {Rule} rule
			 * @return {string}
			 */
			required_with: function(template, rule) {
				var parameters = rule.getParameters();
				return this._replacePlaceholders(rule, template, {
					field: this._getAttributeName(parameters[0])
				});
			},
			
			/**
			 * Required_with_all replacement.
			 *
			 * @param  {string} template
			 * @param  {Rule} rule
			 * @return {string}
			 */
			required_with_all: function(template, rule) {
				var parameters = rule.getParameters();
				var getAttributeName = this._getAttributeName.bind(this);
				return this._replacePlaceholders(rule, template, {
					fields: parameters.map(getAttributeName).join(', ')
				});
			},
			
			/**
			 * Required_without replacement.
			 *
			 * @param  {string} template
			 * @param  {Rule} rule
			 * @return {string}
			 */
			required_without: function(template, rule) {
				var parameters = rule.getParameters();
				return this._replacePlaceholders(rule, template, {
					field: this._getAttributeName(parameters[0])
				});
			},
			
			/**
			 * Required_without_all replacement.
			 *
			 * @param  {string} template
			 * @param  {Rule} rule
			 * @return {string}
			 */
			required_without_all: function(template, rule) {
				var parameters = rule.getParameters();
				var getAttributeName = this._getAttributeName.bind(this);
				return this._replacePlaceholders(rule, template, {
					fields: parameters.map(getAttributeName).join(', ')
				});
			},
			
			/**
			 * After replacement.
			 *
			 * @param  {string} template
			 * @param  {Rule} rule
			 * @return {string}
			 */
			after: function(template, rule) {
				var parameters = rule.getParameters();
				return this._replacePlaceholders(rule, template, {
					after: this._getAttributeName(parameters[0])
				});
			},
			
			/**
			 * Before replacement.
			 *
			 * @param  {string} template
			 * @param  {Rule} rule
			 * @return {string}
			 */
			before: function(template, rule) {
				var parameters = rule.getParameters();
				return this._replacePlaceholders(rule, template, {
					before: this._getAttributeName(parameters[0])
				});
			},
			
			/**
			 * After_or_equal replacement.
			 *
			 * @param  {string} template
			 * @param  {Rule} rule
			 * @return {string}
			 */
			after_or_equal: function(template, rule) {
				var parameters = rule.getParameters();
				return this._replacePlaceholders(rule, template, {
					after_or_equal: this._getAttributeName(parameters[0])
				});
			},
			
			/**
			 * Before_or_equal replacement.
			 *
			 * @param  {string} template
			 * @param  {Rule} rule
			 * @return {string}
			 */
			before_or_equal: function(template, rule) {
				var parameters = rule.getParameters();
				return this._replacePlaceholders(rule, template, {
					before_or_equal: this._getAttributeName(parameters[0])
				});
			},
			
			/**
			 * Same replacement.
			 *
			 * @param  {string} template
			 * @param  {Rule} rule
			 * @return {string}
			 */
			same: function(template, rule) {
				var parameters = rule.getParameters();
				return this._replacePlaceholders(rule, template, {
					same: this._getAttributeName(parameters[0])
				});
			},
		};
		
		function formatter(attribute) {
			return attribute.replace(/[_\[]/g, ' ').replace(/]/g, '');
		}
		
		var attributes = {
			replacements: replacements,
			formatter: formatter
		};
		
		var Messages = function(lang, messages) {
			this.lang = lang;
			this.messages = messages;
			this.customMessages = {};
			this.attributeNames = {};
		};
		
		Messages.prototype = {
			constructor: Messages,
			
			/**
			 * Set custom messages
			 *
			 * @param {object} customMessages
			 * @return {void}
			 */
			_setCustom: function(customMessages) {
				this.customMessages = customMessages || {};
			},
			
			/**
			 * Set custom attribute names.
			 *
			 * @param {object} attributes
			 */
			_setAttributeNames: function(attributes$$1) {
				this.attributeNames = attributes$$1;
			},
			
			/**
			 * Set the attribute formatter.
			 *
			 * @param {fuction} func
			 * @return {void}
			 */
			_setAttributeFormatter: function(func) {
				this.attributeFormatter = func;
			},
			
			/**
			 * Get attribute name to display.
			 *
			 * @param  {string} attribute
			 * @return {string}
			 */
			_getAttributeName: function(attribute) {
				var name = attribute;
				if (this.attributeNames.hasOwnProperty(attribute)) {
					return this.attributeNames[attribute];
				} else if (this.messages.attributes.hasOwnProperty(attribute)) {
					name = this.messages.attributes[attribute];
				}
				
				if (this.attributeFormatter) {
					name = this.attributeFormatter(name);
				}
				
				return name;
			},
			
			/**
			 * Get all messages
			 *
			 * @return {object}
			 */
			all: function() {
				return this.messages;
			},
			
			/**
			 * Render message
			 *
			 * @param  {Rule} rule
			 * @return {string}
			 */
			render: function(rule) {
				if (rule.customMessage) {
					return rule.customMessage;
				}
				var template = this._getTemplate(rule);
				
				var message;
				if (attributes.replacements[rule.name]) {
					message = attributes.replacements[rule.name].apply(this, [template, rule]);
				} else {
					message = this._replacePlaceholders(rule, template, {});
				}
				
				return message;
			},
			
			/**
			 * Get the template to use for given rule
			 *
			 * @param  {Rule} rule
			 * @return {string}
			 */
			_getTemplate: function(rule) {
				
				var messages = this.messages;
				var template = messages.def;
				var customMessages = this.customMessages;
				var formats = [rule.name + '.' + rule.attribute, rule.name];
				
				for (var i = 0, format; i < formats.length; i++) {
					format = formats[i];
					if (customMessages.hasOwnProperty(format)) {
						template = customMessages[format];
						break;
					} else if (messages.hasOwnProperty(format)) {
						template = messages[format];
						break;
					}
				}
				
				if (typeof template === 'object') {
					template = template[rule._getValueType()];
				}
				
				return template;
			},
			
			/**
			 * Replace placeholders in the template using the data object
			 *
			 * @param  {Rule} rule
			 * @param  {string} template
			 * @param  {object} data
			 * @return {string}
			 */
			_replacePlaceholders: function(rule, template, data) {
				var message, attribute;
				
				data.attribute = this._getAttributeName(rule.attribute);
				data[rule.name] = data[rule.name] || rule.getParameters().join(',');
				
				if (typeof template === 'string' && typeof data === 'object') {
					message = template;
					
					for (attribute in data) {
						message = message.replace(new RegExp(':' + attribute, 'g'), data[attribute]);
					}
				}
				
				return message;
			}
			
		};
		
		var messages = Messages;
		
		var en = {
			accepted: 'The :attribute must be accepted.',
			after: 'The :attribute must be after :after.',
			after_or_equal: 'The :attribute must be equal or after :after_or_equal.',
			alpha: 'The :attribute field must contain only alphabetic characters.',
			alpha_dash: 'The :attribute field may only contain alpha-numeric characters, as well as dashes and underscores.',
			alpha_num: 'The :attribute field must be alphanumeric.',
			before: 'The :attribute must be before :before.',
			before_or_equal: 'The :attribute must be equal or before :before_or_equal.',
			between: 'The :attribute field must be between :min and :max.',
			confirmed: 'The :attribute confirmation does not match.',
			email: 'The :attribute format is invalid.',
			date: 'The :attribute is not a valid date format.',
			def: 'The :attribute attribute has errors.',
			digits: 'The :attribute must be :digits digits.',
			different: 'The :attribute and :different must be different.',
			'in': 'The selected :attribute is invalid.',
			integer: 'The :attribute must be an integer.',
			hex: 'The :attribute field should have hexadecimal format',
			min: {
				numeric: 'The :attribute must be at least :min.',
				string: 'The :attribute must be at least :min characters.'
			},
			max: {
				numeric: 'The :attribute may not be greater than :max.',
				string: 'The :attribute may not be greater than :max characters.'
			},
			not_in: 'The selected :attribute is invalid.',
			numeric: 'The :attribute must be a number.',
			present: 'The :attribute field must be present (but can be empty).',
			required: 'The :attribute field is required.',
			required_if: 'The :attribute field is required when :other is :value.',
			required_unless: 'The :attribute field is required when :other is not :value.',
			required_with: 'The :attribute field is required when :field is not empty.',
			required_with_all: 'The :attribute field is required when :fields are not empty.',
			required_without: 'The :attribute field is required when :field is empty.',
			required_without_all: 'The :attribute field is required when :fields are empty.',
			same: 'The :attribute and :same fields must match.',
			size: {
				numeric: 'The :attribute must be :size.',
				string: 'The :attribute must be :size characters.'
			},
			string: 'The :attribute must be a string.',
			url: 'The :attribute format is invalid.',
			regex: 'The :attribute format is invalid.',
			attributes: {}
		};
		
		var require_method = commonjsRequire;
		
		var container = {
			
			messages: {},
			
			/**
			 * Set messages for language
			 *
			 * @param {string} lang
			 * @param {object} rawMessages
			 * @return {void}
			 */
			_set: function(lang, rawMessages) {
				this.messages[lang] = rawMessages;
			},
			
			/**
			 * Set message for given language's rule.
			 *
			 * @param {string} lang
			 * @param {string} attribute
			 * @param {string|object} message
			 * @return {void}
			 */
			_setRuleMessage: function(lang, attribute, message) {
				this._load(lang);
				if (message === undefined) {
					message = this.messages[lang].def;
				}
				
				this.messages[lang][attribute] = message;
			},
			
			/**
			 * Load messages (if not already loaded)
			 *
			 * @param  {string} lang
			 * @return {void}
			 */
			_load: function(lang) {
				if (!this.messages[lang]) {
					try {
						var rawMessages = require_method('./lang/' + lang);
						this._set(lang, rawMessages);
					} catch (e) {
					}
				}
			},
			
			/**
			 * Get raw messages for language
			 *
			 * @param  {string} lang
			 * @return {object}
			 */
			_get: function(lang) {
				this._load(lang);
				return this.messages[lang];
			},
			
			/**
			 * Make messages for given language
			 *
			 * @param  {string} lang
			 * @return {Messages}
			 */
			_make: function(lang) {
				this._load(lang);
				return new messages(lang, this.messages[lang]);
			}
			
		};
		
		var lang = container;
		
		var Errors = function() {
			this.errors = {};
		};
		
		Errors.prototype = {
			constructor: Errors,
			
			/**
			 * Add new error message for given attribute
			 *
			 * @param  {string} attribute
			 * @param  {string} message
			 * @return {void}
			 */
			add: function(attribute, message) {
				if (!this.has(attribute)) {
					this.errors[attribute] = [];
				}
				
				if (this.errors[attribute].indexOf(message) === -1) {
					this.errors[attribute].push(message);
				}
			},
			
			/**
			 * Returns an array of error messages for an attribute, or an empty array
			 *
			 * @param  {string} attribute A key in the data object being validated
			 * @return {array} An array of error messages
			 */
			get: function(attribute) {
				if (this.has(attribute)) {
					return this.errors[attribute];
				}
				
				return [];
			},
			
			/**
			 * Returns the first error message for an attribute, false otherwise
			 *
			 * @param  {string} attribute A key in the data object being validated
			 * @return {string|false} First error message or false
			 */
			first: function(attribute) {
				if (this.has(attribute)) {
					return this.errors[attribute][0];
				}
				
				return false;
			},
			
			/**
			 * Get all error messages from all failing attributes
			 *
			 * @return {Object} Failed attribute names for keys and an array of messages for values
			 */
			all: function() {
				return this.errors;
			},
			
			/**
			 * Determine if there are any error messages for an attribute
			 *
			 * @param  {string}  attribute A key in the data object being validated
			 * @return {boolean}
			 */
			has: function(attribute) {
				if (this.errors.hasOwnProperty(attribute)) {
					return true;
				}
				
				return false;
			}
		};
		
		var errors = Errors;
		
		function AsyncResolvers(onFailedOne, onResolvedAll) {
			this.onResolvedAll = onResolvedAll;
			this.onFailedOne = onFailedOne;
			this.resolvers = {};
			this.resolversCount = 0;
			this.passed = [];
			this.failed = [];
			this.firing = false;
		}
		
		AsyncResolvers.prototype = {
			
			/**
			 * Add resolver
			 *
			 * @param {Rule} rule
			 * @return {integer}
			 */
			add: function(rule) {
				var index = this.resolversCount;
				this.resolvers[index] = rule;
				this.resolversCount++;
				return index;
			},
			
			/**
			 * Resolve given index
			 *
			 * @param  {integer} index
			 * @return {void}
			 */
			resolve: function(index) {
				var rule = this.resolvers[index];
				if (rule.passes === true) {
					this.passed.push(rule);
				} else if (rule.passes === false) {
					this.failed.push(rule);
					this.onFailedOne(rule);
				}
				
				this.fire();
			},
			
			/**
			 * Determine if all have been resolved
			 *
			 * @return {boolean}
			 */
			isAllResolved: function() {
				return (this.passed.length + this.failed.length) === this.resolversCount;
			},
			
			/**
			 * Attempt to fire final all resolved callback if completed
			 *
			 * @return {void}
			 */
			fire: function() {
				
				if (!this.firing) {
					return;
				}
				
				if (this.isAllResolved()) {
					this.onResolvedAll(this.failed.length === 0);
				}
				
			},
			
			/**
			 * Enable firing
			 *
			 * @return {void}
			 */
			enableFiring: function() {
				this.firing = true;
			}
			
		};
		
		var async = AsyncResolvers;
		
		var Validator$1 = function(input, rules, customMessages) {
			var lang$$1 = Validator$1.getDefaultLang();
			this.input = input || {};
			
			this.messages = lang._make(lang$$1);
			this.messages._setCustom(customMessages);
			this.setAttributeFormatter(Validator$1.prototype.attributeFormatter);
			
			this.errors = new errors();
			this.errorCount = 0;
			
			this.hasAsync = false;
			this.rules = this._parseRules(rules);
		};
		
		Validator$1.prototype = {
			
			constructor: Validator$1,
			
			/**
			 * Default language
			 *
			 * @type {string}
			 */
			lang: 'en',
			
			/**
			 * Numeric based rules
			 *
			 * @type {array}
			 */
			numericRules: ['integer', 'numeric'],
			
			/**
			 * Attribute formatter.
			 *
			 * @type {function}
			 */
			attributeFormatter: attributes.formatter,
			
			/**
			 * Run validator
			 *
			 * @return {boolean} Whether it passes; true = passes, false = fails
			 */
			check: function() {
				
				for (var attribute in this.rules) {
					var attributeRules = this.rules[attribute];
					var inputValue = this._objectPath(this.input, attribute);
					
					if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {
						continue;
					}
					
					for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {
						ruleOptions = attributeRules[i];
						rule = this.getRule(ruleOptions.name);
						
						if (!this._isValidatable(rule, inputValue)) {
							continue;
						}
						
						rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);
						if (!rulePassed) {
							this._addFailure(rule);
						}
						
						if (this._shouldStopValidating(attribute, rulePassed)) {
							break;
						}
					}
				}
				
				return this.errorCount === 0;
			},
			
			/**
			 * Run async validator
			 *
			 * @param {function} passes
			 * @param {function} fails
			 * @return {void}
			 */
			checkAsync: function(passes, fails) {
				var _this = this;
				passes = passes || function() {
				};
				fails = fails || function() {
				};
				
				var failsOne = function(rule, message) {
					_this._addFailure(rule, message);
				};
				
				var resolvedAll = function(allPassed) {
					if (allPassed) {
						passes();
					} else {
						fails();
					}
				};
				
				var asyncResolvers = new async(failsOne, resolvedAll);
				
				var validateRule = function(inputValue, ruleOptions, attribute, rule) {
					return function() {
						var resolverIndex = asyncResolvers.add(rule);
						rule.validate(inputValue, ruleOptions.value, attribute, function() {
							asyncResolvers.resolve(resolverIndex);
						});
					};
				};
				
				for (var attribute in this.rules) {
					var attributeRules = this.rules[attribute];
					var inputValue = this._objectPath(this.input, attribute);
					
					if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {
						continue;
					}
					
					for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {
						ruleOptions = attributeRules[i];
						
						rule = this.getRule(ruleOptions.name);
						
						if (!this._isValidatable(rule, inputValue)) {
							continue;
						}
						
						validateRule(inputValue, ruleOptions, attribute, rule)();
					}
				}
				
				asyncResolvers.enableFiring();
				asyncResolvers.fire();
			},
			
			/**
			 * Add failure and error message for given rule
			 *
			 * @param {Rule} rule
			 */
			_addFailure: function(rule) {
				var msg = this.messages.render(rule);
				this.errors.add(rule.attribute, msg);
				this.errorCount++;
			},
			
			/**
			 * Flatten nested object, normalizing { foo: { bar: 1 } } into: { 'foo.bar': 1 }
			 *
			 * @param  {object} nested object
			 * @return {object} flattened object
			 */
			_flattenObject: function(obj) {
				var flattened = {};
				
				function recurse(current, property) {
					if (!property && Object.getOwnPropertyNames(current).length === 0) {
						return;
					}
					if (Object(current) !== current || Array.isArray(current)) {
						flattened[property] = current;
					} else {
						var isEmpty = true;
						for (var p in current) {
							isEmpty = false;
							recurse(current[p], property ? property + "." + p : p);
						}
						if (isEmpty) {
							flattened[property] = {};
						}
					}
				}
				
				if (obj) {
					recurse(obj);
				}
				return flattened;
			},
			
			/**
			 * Extract value from nested object using string path with dot notation
			 *
			 * @param  {object} object to search in
			 * @param  {string} path inside object
			 * @return {any|void} value under the path
			 */
			_objectPath: function(obj, path) {
				if (Object.prototype.hasOwnProperty.call(obj, path)) {
					return obj[path];
				}
				
				var keys = path.replace(/\[(\w+)\]/g, ".$1").replace(/^\./, "").split(".");
				var copy = {};
				for (var attr in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, attr)) {
						copy[attr] = obj[attr];
					}
				}
				
				for (var i = 0, l = keys.length; i < l; i++) {
					if (Object.hasOwnProperty.call(copy, keys[i])) {
						copy = copy[keys[i]];
					} else {
						return;
					}
				}
				return copy;
			},
			
			/**
			 * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }
			 *
			 * @param  {object} rules
			 * @return {object}
			 */
			_parseRules: function(rules) {
				
				var parsedRules = {};
				rules = this._flattenObject(rules);
				
				for (var attribute in rules) {
					
					var rulesArray = rules[attribute];
					
					this._parseRulesCheck(attribute, rulesArray, parsedRules);
				}
				return parsedRules;
				
				
			},
			
			_parseRulesCheck: function(attribute, rulesArray, parsedRules, wildCardValues) {
				if (attribute.indexOf('*') > -1) {
					this._parsedRulesRecurse(attribute, rulesArray, parsedRules, wildCardValues);
				} else {
					this._parseRulesDefault(attribute, rulesArray, parsedRules, wildCardValues);
				}
			},
			
			_parsedRulesRecurse: function(attribute, rulesArray, parsedRules, wildCardValues) {
				var parentPath = attribute.substr(0, attribute.indexOf('*') - 1);
				var propertyValue = this._objectPath(this.input, parentPath);
				
				if (propertyValue) {
					for (var propertyNumber = 0; propertyNumber < propertyValue.length; propertyNumber++) {
						var workingValues = wildCardValues ? wildCardValues.slice() : [];
						workingValues.push(propertyNumber);
						this._parseRulesCheck(attribute.replace('*', propertyNumber), rulesArray, parsedRules, workingValues);
					}
				}
			},
			
			_parseRulesDefault: function(attribute, rulesArray, parsedRules, wildCardValues) {
				var attributeRules = [];
				
				if (rulesArray instanceof Array) {
					rulesArray = this._prepareRulesArray(rulesArray);
				}
				
				if (typeof rulesArray === 'string') {
					rulesArray = rulesArray.split('|');
				}
				
				for (var i = 0, len = rulesArray.length, rule; i < len; i++) {
					rule = typeof rulesArray[i] === 'string' ? this._extractRuleAndRuleValue(rulesArray[i]) : rulesArray[i];
					if (rule.value) {
						rule.value = this._replaceWildCards(rule.value, wildCardValues);
						this._replaceWildCardsMessages(wildCardValues);
					}
					
					if (rules_1.isAsync(rule.name)) {
						this.hasAsync = true;
					}
					attributeRules.push(rule);
				}
				
				parsedRules[attribute] = attributeRules;
			},
			
			_replaceWildCards: function(path, nums) {
				
				if (!nums) {
					return path;
				}
				
				var path2 = path;
				nums.forEach(function(value) {
					if (Array.isArray(path2)) {
						path2 = path2[0];
					}
					pos = path2.indexOf('*');
					if (pos === -1) {
						return path2;
					}
					path2 = path2.substr(0, pos) + value + path2.substr(pos + 1);
				});
				if (Array.isArray(path)) {
					path[0] = path2;
					path2 = path;
				}
				return path2;
			},
			
			_replaceWildCardsMessages: function(nums) {
				var customMessages = this.messages.customMessages;
				var self = this;
				Object.keys(customMessages).forEach(function(key) {
					if (nums) {
						var newKey = self._replaceWildCards(key, nums);
						customMessages[newKey] = customMessages[key];
					}
				});
				
				this.messages._setCustom(customMessages);
			},
			/**
			 * Prepare rules if it comes in Array. Check for objects. Need for type validation.
			 *
			 * @param  {array} rulesArray
			 * @return {array}
			 */
			_prepareRulesArray: function(rulesArray) {
				var rules = [];
				
				for (var i = 0, len = rulesArray.length; i < len; i++) {
					if (typeof rulesArray[i] === 'object') {
						for (var rule in rulesArray[i]) {
							rules.push({
								name: rule,
								value: rulesArray[i][rule]
							});
						}
					} else {
						rules.push(rulesArray[i]);
					}
				}
				
				return rules;
			},
			
			/**
			 * Determines if the attribute is supplied with the original data object.
			 *
			 * @param  {array} attribute
			 * @return {boolean}
			 */
			_suppliedWithData: function(attribute) {
				return this.input.hasOwnProperty(attribute);
			},
			
			/**
			 * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3
			 *
			 * @param  {string} ruleString min:3
			 * @return {object} object containing the name of the rule and value
			 */
			_extractRuleAndRuleValue: function(ruleString) {
				var rule = {},
					ruleArray;
				
				rule.name = ruleString;
				
				if (ruleString.indexOf(':') >= 0) {
					ruleArray = ruleString.split(':');
					rule.name = ruleArray[0];
					rule.value = ruleArray.slice(1).join(":");
				}
				
				return rule;
			},
			
			/**
			 * Determine if attribute has any of the given rules
			 *
			 * @param  {string}  attribute
			 * @param  {array}   findRules
			 * @return {boolean}
			 */
			_hasRule: function(attribute, findRules) {
				var rules = this.rules[attribute] || [];
				for (var i = 0, len = rules.length; i < len; i++) {
					if (findRules.indexOf(rules[i].name) > -1) {
						return true;
					}
				}
				return false;
			},
			
			/**
			 * Determine if attribute has any numeric-based rules.
			 *
			 * @param  {string}  attribute
			 * @return {Boolean}
			 */
			_hasNumericRule: function(attribute) {
				return this._hasRule(attribute, this.numericRules);
			},
			
			/**
			 * Determine if rule is validatable
			 *
			 * @param  {Rule}   rule
			 * @param  {mixed}  value
			 * @return {boolean}
			 */
			_isValidatable: function(rule, value) {
				if (rules_1.isImplicit(rule.name)) {
					return true;
				}
				
				return this.getRule('required').validate(value);
			},
			
			/**
			 * Determine if we should stop validating.
			 *
			 * @param  {string} attribute
			 * @param  {boolean} rulePassed
			 * @return {boolean}
			 */
			_shouldStopValidating: function(attribute, rulePassed) {
				
				var stopOnAttributes = this.stopOnAttributes;
				if (typeof stopOnAttributes === 'undefined' || stopOnAttributes === false || rulePassed === true) {
					return false;
				}
				
				if (stopOnAttributes instanceof Array) {
					return stopOnAttributes.indexOf(attribute) > -1;
				}
				
				return true;
			},
			
			/**
			 * Set custom attribute names.
			 *
			 * @param {object} attributes
			 * @return {void}
			 */
			setAttributeNames: function(attributes$$1) {
				this.messages._setAttributeNames(attributes$$1);
			},
			
			/**
			 * Set the attribute formatter.
			 *
			 * @param {fuction} func
			 * @return {void}
			 */
			setAttributeFormatter: function(func) {
				this.messages._setAttributeFormatter(func);
			},
			
			/**
			 * Get validation rule
			 *
			 * @param  {string} name
			 * @return {Rule}
			 */
			getRule: function(name) {
				return rules_1.make(name, this);
			},
			
			/**
			 * Stop on first error.
			 *
			 * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.
			 * @return {void}
			 */
			stopOnError: function(attributes$$1) {
				this.stopOnAttributes = attributes$$1;
			},
			
			/**
			 * Determine if validation passes
			 *
			 * @param {function} passes
			 * @return {boolean|undefined}
			 */
			passes: function(passes) {
				var async$$1 = this._checkAsync('passes', passes);
				if (async$$1) {
					return this.checkAsync(passes);
				}
				return this.check();
			},
			
			/**
			 * Determine if validation fails
			 *
			 * @param {function} fails
			 * @return {boolean|undefined}
			 */
			fails: function(fails) {
				var async$$1 = this._checkAsync('fails', fails);
				if (async$$1) {
					return this.checkAsync(function() {
					}, fails);
				}
				return !this.check();
			},
			
			/**
			 * Check if validation should be called asynchronously
			 *
			 * @param  {string}   funcName Name of the caller
			 * @param  {function} callback
			 * @return {boolean}
			 */
			_checkAsync: function(funcName, callback) {
				var hasCallback = typeof callback === 'function';
				if (this.hasAsync && !hasCallback) {
					throw funcName + ' expects a callback when async rules are being tested.';
				}
				
				return this.hasAsync || hasCallback;
			}
			
		};
		
		/**
		 * Set messages for language
		 *
		 * @param {string} lang
		 * @param {object} messages
		 * @return {this}
		 */
		Validator$1.setMessages = function(lang$$1, messages) {
			lang._set(lang$$1, messages);
			return this;
		};
		
		/**
		 * Get messages for given language
		 *
		 * @param  {string} lang
		 * @return {Messages}
		 */
		Validator$1.getMessages = function(lang$$1) {
			return lang._get(lang$$1);
		};
		
		/**
		 * Set default language to use
		 *
		 * @param {string} lang
		 * @return {void}
		 */
		Validator$1.useLang = function(lang$$1) {
			this.prototype.lang = lang$$1;
		};
		
		/**
		 * Get default language
		 *
		 * @return {string}
		 */
		Validator$1.getDefaultLang = function() {
			return this.prototype.lang;
		};
		
		/**
		 * Set the attribute formatter.
		 *
		 * @param {fuction} func
		 * @return {void}
		 */
		Validator$1.setAttributeFormatter = function(func) {
			this.prototype.attributeFormatter = func;
		};
		
		/**
		 * Stop on first error.
		 *
		 * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.
		 * @return {void}
		 */
		Validator$1.stopOnError = function(attributes$$1) {
			this.prototype.stopOnAttributes = attributes$$1;
		};
		
		/**
		 * Register custom validation rule
		 *
		 * @param  {string}   name
		 * @param  {function} fn
		 * @param  {string}   message
		 * @return {void}
		 */
		Validator$1.register = function(name, fn, message) {
			var lang$$1 = Validator$1.getDefaultLang();
			rules_1.register(name, fn);
			lang._setRuleMessage(lang$$1, name, message);
		};
		
		/**
		 * Register custom validation rule
		 *
		 * @param  {string}   name
		 * @param  {function} fn
		 * @param  {string}   message
		 * @return {void}
		 */
		Validator$1.registerImplicit = function(name, fn, message) {
			var lang$$1 = Validator$1.getDefaultLang();
			rules_1.registerImplicit(name, fn);
			lang._setRuleMessage(lang$$1, name, message);
		};
		
		/**
		 * Register asynchronous validation rule
		 *
		 * @param  {string}   name
		 * @param  {function} fn
		 * @param  {string}   message
		 * @return {void}
		 */
		Validator$1.registerAsync = function(name, fn, message) {
			var lang$$1 = Validator$1.getDefaultLang();
			rules_1.registerAsync(name, fn);
			lang._setRuleMessage(lang$$1, name, message);
		};
		
		/**
		 * Register asynchronous validation rule
		 *
		 * @param  {string}   name
		 * @param  {function} fn
		 * @param  {string}   message
		 * @return {void}
		 */
		Validator$1.registerAsyncImplicit = function(name, fn, message) {
			var lang$$1 = Validator$1.getDefaultLang();
			rules_1.registerAsyncImplicit(name, fn);
			lang._setRuleMessage(lang$$1, name, message);
		};
		
		/**
		 * Register validator for missed validation rule
		 *
		 * @param  {string}   name
		 * @param  {function} fn
		 * @param  {string}   message
		 * @return {void}
		 */
		Validator$1.registerMissedRuleValidator = function(fn, message) {
			rules_1.registerMissedRuleValidator(fn, message);
		};
		
		var validator = Validator$1;
		
		function _slicedToArray(arr, i) {
			return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
		}
		
		function _toConsumableArray(arr) {
			return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
		}
		
		function _arrayWithoutHoles(arr) {
			if (Array.isArray(arr)) {
				for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
					arr2[i] = arr[i];
				}
				
				return arr2;
			}
		}
		
		function _arrayWithHoles(arr) {
			if (Array.isArray(arr)) {
				return arr;
			}
		}
		
		function _iterableToArray(iter) {
			if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") {
				return Array.from(iter);
			}
		}
		
		function _iterableToArrayLimit(arr, i) {
			var _arr = [];
			var _n = true;
			var _d = false;
			var _e = undefined;
			
			try {
				for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
					_arr.push(_s.value);
					
					if (i && _arr.length === i) {
						break;
					}
				}
			} catch (err) {
				_d = true;
				_e = err;
			} finally {
				try {
					if (!_n && _i["return"] != null) {
						_i["return"]();
					}
				} finally {
					if (_d) {
						throw _e;
					}
				}
			}
			
			return _arr;
		}
		
		function _nonIterableSpread() {
			throw new TypeError("Invalid attempt to spread non-iterable instance");
		}
		
		function _nonIterableRest() {
			throw new TypeError("Invalid attempt to destructure non-iterable instance");
		}
		
		var resolveElement = function resolveElement(target) {
			if ('string' === typeof target) {
				return document.querySelector(target);
			}
			
			return target;
		};
		
		var getData = function getData(form) {
			var formData = new FormData(form);
			var values = {};
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;
			
			try {
				for (var _iterator = formData.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var _step$value = _slicedToArray(_step.value, 2),
						key = _step$value[0],
						value = _step$value[1];
					
					var name = key.replace(/\[]$/, '');
					var multiple = name !== key;
					
					if (values[name]) {
						if (!(values[name] instanceof Array)) {
							values[name] = [values[name]];
						}
						
						values[name].push(value);
					} else {
						values[name] = multiple ? [value] : value;
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return != null) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
			
			return values;
		};
		
		var booted = false;
		
		var boot = function boot() {
			if (!booted) {
				Validator.registerMissedRuleValidator(function() {
					return true;
				}, '');
				Validator.useLang('en');
			}
			
			booted = true;
		};
		
		var config = {
			'templates': {
				'error': {
					'prefix': '<li>',
					'suffix': '</li>'
				}
			},
			'classnames': {
				'none': {},
				'valid': {},
				'invalid': {}
			}
		};
		var configure = function configure(customConfig) {
			config = customConfig;
		}; // FIXME: This still needs major perf work
		
		var defaultRenderer = function defaultRenderer(_ref) {
			var form = _ref.form,
				errors = _ref.errors,
				data = _ref.data,
				rules = _ref.rules,
				refs = _ref.refs,
				touched = _ref.touched;
			var _config = config,
				templates = _config.templates,
				classnames = _config.classnames;
			Object.keys(rules).forEach(function(name) {
				// Stop if we don't have refs to this field
				if (!(name in refs)) {
					return;
				}
				
				var fails = touched.has(name) && name in errors;
				var passes = touched.has(name) && !fails && name in data;
				
				if ('errors' in refs[name]) {
					if (passes) {
						refs[name].errors[0].classList.add('hidden');
						refs[name].errors[0].innerHTML = '';
					} else if (fails) {
						// TODO: Maybe hide help text
						refs[name].errors[0].classList.remove('hidden');
						refs[name].errors[0].innerHTML = errors[name].map(function(message) {
							return "".concat(templates.error.prefix).concat(message).concat(templates.error.suffix);
						}).join('');
					}
				}
				
				Object.entries(refs[name]).forEach(function(_ref2) {
					var _ref3 = _slicedToArray(_ref2, 2),
						name = _ref3[0],
						elements = _ref3[1];
					
					elements.forEach(function(element) {
						if (name in classnames.valid) {
							if (passes) {
								var _element$classList;
								
								(_element$classList = element.classList).add.apply(_element$classList, _toConsumableArray(classnames.valid[name].split(' ')));
							} else {
								var _element$classList2;
								
								(_element$classList2 = element.classList).remove.apply(_element$classList2, _toConsumableArray(classnames.valid[name].split(' ')));
							}
						}
						
						if (name in classnames.invalid) {
							if (fails) {
								var _element$classList3;
								
								(_element$classList3 = element.classList).add.apply(_element$classList3, _toConsumableArray(classnames.invalid[name].split(' ')));
							} else {
								var _element$classList4;
								
								(_element$classList4 = element.classList).remove.apply(_element$classList4, _toConsumableArray(classnames.invalid[name].split(' ')));
							}
						}
						
						if (name in classnames.none) {
							if (!passes && !fails) {
								var _element$classList5;
								
								(_element$classList5 = element.classList).add.apply(_element$classList5, _toConsumableArray(classnames.none[name].split(' ')));
							} else {
								var _element$classList6;
								
								(_element$classList6 = element.classList).remove.apply(_element$classList6, _toConsumableArray(classnames.none[name].split(' ')));
							}
						}
					});
				});
			});
		};
		
		var renderer = defaultRenderer;
		var setRenderer = function setRenderer(customRenderer) {
			renderer = customRenderer;
		};
		var supported = 'undefined' !== typeof FormData && 'getAll' in FormData.prototype;
		var connect = function connect(target) {
			var rules = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
			
			if (!supported) {
				return null;
			}
			
			boot();
			var form = resolveElement(target);
			var refs = {};
			form.querySelectorAll('[data-aire-component]').forEach(function(element) {
				if ('aireFor' in element.dataset) {
					var parent = element.dataset.aireFor;
					var component = element.dataset.aireComponent;
					refs[parent] = refs[parent] || {};
					
					if (component in refs[parent]) {
						refs[parent][component].push(element);
					} else {
						refs[parent][component] = [element];
					}
				}
			});
			var validator;
			var connected = true;
			var touched = new Set();
			
			var touch = function touch(e) {
				var name = e.target.getAttribute('name');
				
				if (name) {
					touched.add(name.replace(/\[]$/, ''));
				}
			};
			
			var debounce;
			
			var run = function run(e) {
				if ('undefined' !== typeof e && 'target' in e) {
					touch(e);
				}
				
				var latestRun = 0;
				clearTimeout(debounce);
				debounce = setTimeout(function() {
					var data = getData(form);
					validator = new Validator(data, rules, {}); // TODO: Custom messages
					// Because some validators may run async, we'll store a reference
					// to the run "id" so that we can cancel the callbacks if another
					// validation started before the callbacks were fired
					
					var activeRun = ++latestRun; // If this is the first run, "touch" anything that has a value
					
					if (1 === activeRun) {
						Object.entries(data).forEach(function(_ref4) {
							var _ref5 = _slicedToArray(_ref4, 2),
								key = _ref5[0],
								value = _ref5[1];
							
							if (null === value || 'undefiined' === typeof value || '' === value) {
								return;
							}
							
							if (Array.isArray(value) && 0 === value.length) {
								return;
							}
							
							touched.add(key);
						});
					}
					
					var validated = function validated() {
						if (connected && activeRun === latestRun) {
							renderer({
								form: form,
								rules: rules,
								touched: touched,
								refs: refs,
								data: data,
								errors: validator.errors.all()
							});
						}
					};
					
					validator.checkAsync(validated, validated);
				}, 250);
			};
			
			form.addEventListener('change', run, true);
			form.addEventListener('keyup', run, true);
			form.addEventListener('focus', touch, true);
			run();
			
			var disconnect = function disconnect() {
				connected = false;
				clearTimeout(debounce);
				form.removeEventListener('change', run);
				form.removeEventListener('keyup', run);
				form.removeEventListener('focus', touch);
			};
			
			return {
				get valid() {
					return 'undefined' !== typeof validator && 0 === Object.keys(validator.errors.all()).length;
				},
				
				get data() {
					return 'undefined' === typeof validator ? getData(form) : validator.input;
				},
				
				run: run,
				disconnect: disconnect
			};
		};
		
		var Aire = /*#__PURE__*/Object.freeze({
			configure: configure,
			setRenderer: setRenderer,
			supported: supported,
			connect: connect
		});
		
		validator.setMessages('en', en);
		window.Validator = validator;
		window.Aire = Aire;
		
	}());
	</script>
	
	<script defer>
	document.addEventListener('DOMContentLoaded', function() {
		Aire.configure({
			"templates": { "error": { "prefix": "<li class=\"block mt-1 text-red-500 text-sm font-bold\">", "suffix": "<\/li>" } },
			"classnames": {
				"none": {
					"input": "text-gray-900",
					"select": "text-gray-900",
					"textarea": "text-gray-900",
					"group_errors": "hidden",
					"group_help_text": "text-gray-600"
				},
				"valid": {
					"label": "text-green-600",
					"input": "border-green-600 text-green-700",
					"select": "border-green-600 text-green-700",
					"textarea": "border-green-600 text-green-700",
					"group_errors": "hidden",
					"group_help_text": "text-green-600 opacity-50"
				},
				"invalid": {
					"label": "text-red-600",
					"input": "border-red-600 text-red-700",
					"select": "border-red-600 text-red-700",
					"textarea": "border-red-600 text-red-700",
					"group_help_text": "text-red-600 opacity-50"
				}
			}
		});
	});
	</script>
	
	<script defer>
	document.addEventListener('DOMContentLoaded', function() {
		window.$aire0 = Aire.connect('[data-aire-id="0"]', {
			"accepted": "accepted",
			"after_reference": "after:reference_date",
			"after_or_equal_reference": "after_or_equal:reference_date",
			"before_reference": "before:reference_date",
			"before_or_equal_reference": "before_or_equal:reference_date",
			"date": "date",
			"alpha": "alpha",
			"alpha_dash": "alpha_dash",
			"alpha_num": "alpha_num",
			"array": "array",
			"between": "between:2,4",
			"confirmed": "confirmed",
			"different": "different:different_from",
			"digits": "digits:5",
			"email": "email",
			"in": "in:foo,bar,baz",
			"not_in": "not_in:foo,bar,baz",
			"integer": "integer",
			"min_string": "min:5",
			"min_number": "numeric|min:5",
			"max_string": "max:5",
			"max_number": "numeric|max:5",
			"regex": "regex:\/^[a-z]\\d{4}$\/i",
			"numeric": "numeric",
			"required": "required",
			"required_if": "required_if:required,yes",
			"required_unless": "required_unless:required_if,no",
			"required_with": "required_with:required_unless",
			"required_with_all": "required_with_all:required,required_if,required_unless,required_with",
			"required_without": "required_without:required_with_all",
			"required_without_all": "required_without_all:required,required_if,required_unless,required_with,required_with_all,required_without",
			"same": "same:same_target",
			"size_string": "size:5",
			"size_number": "numeric|size:5",
			"url": "url"
		});
	});
	</script>
</form>
</body>
</html>
